/*!
  * element3 v0.0.12
  * (c) 2020 kkb
  * @license MIT
  */
import { toRefs, ref, computed, openBlock, createBlock, Transition, withCtx, withDirectives, createVNode, createCommentVNode, renderSlot, createTextVNode, toDisplayString, vShow, inject, unref, getCurrentInstance, onMounted, resolveComponent, withModifiers, Fragment, mergeProps, provide, onUnmounted } from 'vue';
import ElIcon from 'element-ui/packages/icon';

var TYPE_CLASSES_MAP = {
  success: 'el-icon-success',
  warning: 'el-icon-warning',
  error: 'el-icon-error'
};
var script = {
  name: 'ElAlert',
  props: {
    title: {
      type: String,
      default: ''
    },
    description: {
      type: String,
      default: ''
    },
    type: {
      type: String,
      default: 'info'
    },
    closable: {
      type: Boolean,
      default: true
    },
    closeText: {
      type: String,
      default: ''
    },
    showIcon: Boolean,
    center: Boolean,
    effect: {
      type: String,
      default: 'light',
      validator: function (value) {
        return ['light', 'dark'].indexOf(value) !== -1
      }
    }
  },
  emits: ['close'],
  setup: function setup(props, ref$1) {
    var emit = ref$1.emit;
    var slots = ref$1.slots;

    var ref$2 = toRefs(props);
    var description = ref$2.description;
    var type = ref$2.type;

    var visible = ref(true);
    var close = function () {
      visible.value = false;
      emit('close');
    };

    var typeClass = computed(function () {
      return ("el-alert--" + (type.value))
    });

    var iconClass = computed(function () {
      return TYPE_CLASSES_MAP[type.value] || 'el-icon-info'
    });

    var isBigIcon = computed(function () {
      return description.value || slots.default ? 'is-big' : ''
    });

    var isBoldTitle = computed(function () {
      return description.value || slots.default ? 'is-bold' : ''
    });

    return {
      visible: visible,
      typeClass: typeClass,
      iconClass: iconClass,
      isBigIcon: isBigIcon,
      isBoldTitle: isBoldTitle,
      close: close
    }
  }
};

var _hoisted_1 = { class: "el-alert__content" };
var _hoisted_2 = {
  key: 1,
  class: "el-alert__description"
};
var _hoisted_3 = {
  key: 2,
  class: "el-alert__description"
};

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, { name: "el-alert-fade" }, {
    default: withCtx(function () { return [
      withDirectives(createVNode("div", {
        class: ["el-alert", [_ctx.typeClass, _ctx.center ? 'is-center' : '', 'is-' + _ctx.effect]],
        role: "alert"
      }, [
        (_ctx.showIcon)
          ? (openBlock(), createBlock("i", {
              key: 0,
              class: ["el-alert__icon", [_ctx.iconClass, _ctx.isBigIcon]]
            }, null, 2 /* CLASS */))
          : createCommentVNode("v-if", true),
        createVNode("div", _hoisted_1, [
          (_ctx.title || _ctx.$slots.title)
            ? (openBlock(), createBlock("span", {
                key: 0,
                class: ["el-alert__title", [_ctx.isBoldTitle]]
              }, [
                renderSlot(_ctx.$slots, "title", {}, function () { return [
                  createTextVNode(toDisplayString(_ctx.title), 1 /* TEXT */)
                ]; })
              ], 2 /* CLASS */))
            : createCommentVNode("v-if", true),
          (_ctx.$slots.default && !_ctx.description)
            ? (openBlock(), createBlock("p", _hoisted_2, [
                renderSlot(_ctx.$slots, "default")
              ]))
            : createCommentVNode("v-if", true),
          (_ctx.description && !_ctx.$slots.default)
            ? (openBlock(), createBlock("p", _hoisted_3, toDisplayString(_ctx.description), 1 /* TEXT */))
            : createCommentVNode("v-if", true),
          withDirectives(createVNode("i", {
            class: ["el-alert__closebtn", {
            'is-customed': _ctx.closeText !== '',
            'el-icon-close': _ctx.closeText === ''
          }],
            onClick: _cache[1] || (_cache[1] = function () {
              var args = [], len = arguments.length;
              while ( len-- ) args[ len ] = arguments[ len ];

              return (_ctx.close.apply(_ctx, args));
      })
          }, toDisplayString(_ctx.closeText), 3 /* TEXT, CLASS */), [
            [vShow, _ctx.closable]
          ])
        ])
      ], 2 /* CLASS */), [
        [vShow, _ctx.visible]
      ])
    ]; }),
    _: 1
  }))
}

script.render = render;
script.__file = "packages/alert/Alert.vue";

/* istanbul ignore next */
script.install = function (app) {
  app.component(script.name, script);
};

var script$1 = {
  name: 'ElContainer',
  props: {
    direction: String
  },
  setup: function setup(props, ref) {
    var slots = ref.slots;

    var ref$1 = toRefs(props);
    var direction = ref$1.direction;

    var isVertical = computed(function () {
      if (direction === 'vertical') {
        return true
      } else if (direction === 'horizontal') {
        return false
      }
      if (slots && slots.default) {
        return slots.default().some(function (vNode) {
          var tag = vNode.type && vNode.type.name;
          return tag === 'ElHeader' || tag === 'ElFooter'
        })
      } else {
        return false
      }
    });
    return {
      isVertical: isVertical
    }
  }
};

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("section", {
    class: ["el-container", { 'is-vertical': _ctx.isVertical }]
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2 /* CLASS */))
}

script$1.render = render$1;
script$1.__file = "packages/container/Container.vue";

/* istanbul ignore next */
script$1.install = function (app) {
  app.component(script$1.name, script$1);
};

var script$2 = {
  name: 'ElButton',

  props: {
    type: {
      type: String,
      default: 'default'
    },
    size: {
      type: String,
      default: ''
    },
    icon: {
      type: String,
      default: ''
    },
    nativeType: {
      type: String,
      default: 'button'
    },
    loading: Boolean,
    disabled: Boolean,
    plain: Boolean,
    autofocus: Boolean,
    round: Boolean,
    circle: Boolean
  },
  emits: ['click'],
  setup: function setup(props, ctx) {
    var ref = toRefs(props);
    var size = ref.size;
    var disabled = ref.disabled;

    var buttonSize = useButtonSize(size);
    var buttonDisabled = useButtonDisabled(disabled);

    var handleClick = function (evt) {
      ctx.emit('click', evt);
    };

    return {
      handleClick: handleClick,
      buttonSize: buttonSize,
      buttonDisabled: buttonDisabled
    }
  }
};

var useButtonSize = function (size) {
  var elFormItem = inject('elFormItem', {});

  var _elFormItemSize = computed(function () {
    return unref(elFormItem.elFormItemSize)
  });

  var buttonSize = computed(function () {
    return (
      size.value ||
      _elFormItemSize.value ||
      (getCurrentInstance().proxy.$ELEMENT || {}).size
    )
  });

  return buttonSize
};

var useButtonDisabled = function (disabled) {
  var elForm = inject('elForm', {});

  var buttonDisabled = computed(function () {
    return disabled.value || unref(elForm.disabled)
  });

  return buttonDisabled
};

var _hoisted_1$1 = {
  key: 0,
  class: "el-icon-loading"
};
var _hoisted_2$1 = { key: 2 };

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("button", {
    class: ["el-button", [
      _ctx.type ? 'el-button--' + _ctx.type : '',
      _ctx.buttonSize ? 'el-button--' + _ctx.buttonSize : '',
      {
        'is-disabled': _ctx.buttonDisabled,
        'is-loading': _ctx.loading,
        'is-plain': _ctx.plain,
        'is-round': _ctx.round,
        'is-circle': _ctx.circle
      }
    ]],
    onClick: _cache[1] || (_cache[1] = function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return (_ctx.handleClick.apply(_ctx, args));
  }),
    disabled: _ctx.buttonDisabled || _ctx.loading,
    autofocus: _ctx.autofocus,
    type: _ctx.nativeType
  }, [
    (_ctx.loading)
      ? (openBlock(), createBlock("i", _hoisted_1$1))
      : createCommentVNode("v-if", true),
    (_ctx.icon && !_ctx.loading)
      ? (openBlock(), createBlock("i", {
          key: 1,
          class: _ctx.icon
        }, null, 2 /* CLASS */))
      : createCommentVNode("v-if", true),
    (_ctx.$slots.default)
      ? (openBlock(), createBlock("span", _hoisted_2$1, [
          renderSlot(_ctx.$slots, "default")
        ]))
      : createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, ["disabled", "autofocus", "type"]))
}

script$2.render = render$2;
script$2.__file = "packages/button/Button.vue";

/* istanbul ignore next */
script$2.install = function (app) {
  app.component(script$2.name, script$2);
};

var script$3 = {
  props: {
    type: {
      type: String
    },
    active: {
      type: Boolean,
      default: false
    },
    text: {
      type: String,
      default: ''
    },
    iconClass: {
      type: String,
      default: ''
    }
  }
};

var _hoisted_1$2 = { key: 0 };

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  var obj;

  return (_ctx.iconClass || _ctx.text)
    ? (openBlock(), createBlock("span", {
        key: 0,
        class: ( obj = {
      'el-switch__label': true,
      'is-active': _ctx.active
    }, obj[("el-switch__label--" + (_ctx.type))] = true, obj )
      }, [
        createVNode("i", {
          class: [_ctx.iconClass]
        }, null, 2 /* CLASS */),
        (!_ctx.iconClass)
          ? (openBlock(), createBlock("span", _hoisted_1$2, toDisplayString(_ctx.text), 1 /* TEXT */))
          : createCommentVNode("v-if", true)
      ], 2 /* CLASS */))
    : createCommentVNode("v-if", true)
}

script$3.render = render$3;
script$3.__file = "packages/switch/SwitchLabel.vue";

var script$4 = {
  name: 'ElSwitch',
  components: {
    SwitchLabel: script$3
  },
  props: {
    modelValue: {
      type: [Boolean, String, Number],
      default: false
    },
    activeValue: {
      type: [Boolean, String, Number],
      default: true
    },
    inactiveValue: {
      type: [Boolean, String, Number],
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 40
    },
    activeText: String,
    inactiveText: String,
    activeIconClass: {
      type: String,
      default: ''
    },
    inactiveIconClass: {
      type: String,
      default: ''
    },
    activeColor: {
      type: String,
      default: ''
    },
    inactiveColor: {
      type: String,
      default: ''
    }
  },
  emits: ['update:modelValue', 'change'],
  setup: function setup(props, ref) {
    var emit = ref.emit;

    var ref$1 = toRefs(props);
    var activeValue = ref$1.activeValue;
    var inactiveValue = ref$1.inactiveValue;
    var modelValue = ref$1.modelValue;
    var disabled = ref$1.disabled;
    var activeColor = ref$1.activeColor;
    var inactiveColor = ref$1.inactiveColor;

    useNormalizeModelValue({
      modelValue: modelValue,
      activeValue: activeValue,
      inactiveValue: inactiveValue,
      emit: emit
    });

    var isChecked = computed(function () {
      return modelValue.value === activeValue.value
    });

    var backgroundColor = computed(function () {
      return isChecked.value ? activeColor.value : inactiveColor.value
    });

    var ref$2 = useClick({
      isChecked: isChecked,
      inactiveValue: inactiveValue,
      activeValue: activeValue,
      disabled: disabled,
      emit: emit
    });
    var handleClick = ref$2.handleClick;

    return {
      isChecked: isChecked,
      backgroundColor: backgroundColor,
      handleClick: handleClick
    }
  }
};

var useNormalizeModelValue = function (ref) {
  var modelValue = ref.modelValue;
  var activeValue = ref.activeValue;
  var inactiveValue = ref.inactiveValue;
  var emit = ref.emit;

  onMounted(function () {
    if (
      modelValue.value !== activeValue.value &&
      modelValue.value !== inactiveValue.value
    ) {
      emit('update:modelValue', inactiveValue.value);
    }
  });
};

var useClick = function (ref) {
  var isChecked = ref.isChecked;
  var inactiveValue = ref.inactiveValue;
  var activeValue = ref.activeValue;
  var disabled = ref.disabled;
  var emit = ref.emit;

  var getNewValue = function () {
    return isChecked.value ? inactiveValue.value : activeValue.value
  };

  var handleClick = function () {
    if (disabled.value) { return }

    var newValue = getNewValue();
    emit('update:modelValue', newValue);
    emit('change', newValue);
  };

  return {
    handleClick: handleClick
  }
};

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_SwitchLabel = resolveComponent("SwitchLabel");

  return (openBlock(), createBlock("div", {
    class: ["el-switch", { 'is-checked': _ctx.isChecked, 'is-disabled': _ctx.disabled }],
    onClick: _cache[1] || (_cache[1] = withModifiers(function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return (_ctx.handleClick.apply(_ctx, args));
  }, ["prevent"]))
  }, [
    createVNode(_component_SwitchLabel, {
      active: !_ctx.isChecked,
      type: "left",
      text: _ctx.inactiveText,
      iconClass: _ctx.inactiveIconClass
    }, null, 8 /* PROPS */, ["active", "text", "iconClass"]),
    createVNode("span", {
      class: "el-switch__core",
      ref: "core",
      style: {
        width: _ctx.width + 'px',
        background: _ctx.backgroundColor,
        'border-color': _ctx.backgroundColor
      }
    }, null, 4 /* STYLE */),
    createVNode(_component_SwitchLabel, {
      active: _ctx.isChecked,
      type: "right",
      text: _ctx.activeText,
      iconClass: _ctx.activeIconClass
    }, null, 8 /* PROPS */, ["active", "text", "iconClass"])
  ], 2 /* CLASS */))
}

script$4.render = render$4;
script$4.__file = "packages/switch/Switch.vue";

/* istanbul ignore next */
script$4.install = function (app) {
  app.component(script$4.name, script$4);
};

var script$5 = {
  name: 'ElProgress',
  props: {
    type: {
      type: String,
      default: 'line',
      validator: function (val) { return ['line', 'circle', 'dashboard'].indexOf(val) > -1; }
    },
    percentage: {
      type: Number,
      default: 0,
      required: true,
      validator: function (val) { return val >= 0 && val <= 100; }
    },
    status: {
      type: String,
      validator: function (val) { return ['success', 'exception', 'warning'].indexOf(val) > -1; }
    },
    strokeWidth: {
      type: Number,
      default: 6
    },
    strokeLinecap: {
      type: String,
      default: 'round'
    },
    textInside: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 126
    },
    showText: {
      type: Boolean,
      default: true
    },
    color: {
      type: [String, Array, Function],
      default: ''
    },
    format: Function
  },
  setup: function setup(props) {
    var ref = toRefs(props);
    var percentage = ref.percentage;
    var color = ref.color;
    var strokeWidth = ref.strokeWidth;
    var width = ref.width;
    var type = ref.type;
    var status = ref.status;
    var format = ref.format;

    var getCurrentColor = function (percentage) {
      if (typeof color.value === 'function') {
        return color.value(percentage)
      } else if (typeof color.value === 'string') {
        return color.value
      } else {
        return getLevelColor(percentage)
      }
    };

    var getLevelColor = function (percentage) {
      var colorArray = getColorArray().sort(
        function (a, b) { return a.percentage - b.percentage; }
      );

      for (var i = 0; i < colorArray.length; i++) {
        if (colorArray[i].percentage > percentage) {
          return colorArray[i].color
        }
      }
      return colorArray[colorArray.length - 1].color
    };

    var getColorArray = function () {
      var span = 100 / color.value.length;
      return color.value.map(function (seriesColor, index) {
        if (typeof seriesColor === 'string') {
          return {
            color: seriesColor,
            progress: (index + 1) * span
          }
        }
        return seriesColor
      })
    };

    var barStyle = useBarStyle(percentage, getCurrentColor);
    var relativeStrokeWidth = useRelativeStrokeWidth(strokeWidth, width);
    var radius = useRadius(type, relativeStrokeWidth);
    var trackPath = useTrackPath(radius, type);
    var perimeter = usePerimeter(radius);
    var rate = useRate(type);
    var strokeDashoffset = useStrokeDashoffset(perimeter, rate);
    var trailPathStyle = useTrailPathStyle(perimeter, rate, strokeDashoffset);
    var circlePathStyle = useCirclePathStyle(
      perimeter,
      rate,
      percentage,
      strokeDashoffset
    );
    var stroke = useStroke(color, getCurrentColor, percentage, status);
    var iconClass = useIconClass(status, type);
    var progressTextSize = useProgressTextSize(type, strokeWidth, width);
    var content = useContent(format, percentage);

    return {
      barStyle: barStyle,
      relativeStrokeWidth: relativeStrokeWidth,
      trackPath: trackPath,
      trailPathStyle: trailPathStyle,
      circlePathStyle: circlePathStyle,
      stroke: stroke,
      iconClass: iconClass,
      progressTextSize: progressTextSize,
      content: content
    }
  }
};

var useBarStyle = function (percentage, getCurrentColor) {
  var barStyle = computed(function () {
    var style = {};
    style.width = percentage.value + '%';
    style.backgroundColor = getCurrentColor(percentage.value);
    return style
  });
  return barStyle
};

var useRelativeStrokeWidth = function (strokeWidth, width) {
  var relativeStrokeWidth = computed(function () {
    return ((strokeWidth.value / width.value) * 100).toFixed(1)
  });
  return relativeStrokeWidth
};

var useRadius = function (type, relativeStrokeWidth) {
  var radius = computed(function () {
    if (type.value === 'circle' || type.value === 'dashboard') {
      return parseInt(50 - parseFloat(relativeStrokeWidth.value) / 2, 10)
    } else {
      return 0
    }
  });
  return radius
};

var useTrackPath = function (radius, type) {
  var trackPath = computed(function () {
    var isDashboard = type.value === 'dashboard';
    return ("\n          M 50 50\n          m 0 " + (isDashboard ? '' : '-') + (radius.value) + "\n          a " + (radius.value) + " " + (radius.value) + " 0 1 1 0 " + (isDashboard ? '-' : '') + (radius.value * 2) + "\n          a " + (radius.value) + " " + (radius.value) + " 0 1 1 0 " + (isDashboard ? '' : '-') + (radius.value * 2) + "\n          ")
  });
  return trackPath
};

var usePerimeter = function (radius) {
  var perimeter = computed(function () {
    return 2 * Math.PI * radius.value
  });
  return perimeter
};

var useRate = function (type) {
  var rate = computed(function () {
    return type.value === 'dashboard' ? 0.75 : 1
  });
  return rate
};

var useStrokeDashoffset = function (perimeter, rate) {
  var strokeDashoffset = computed(function () {
    var offset = (-1 * perimeter.value * (1 - rate.value)) / 2;
    return (offset + "px")
  });
  return strokeDashoffset
};

var useTrailPathStyle = function (perimeter, rate, strokeDashoffset) {
  var trailPathStyle = computed(function () {
    return {
      strokeDasharray: ((perimeter.value * rate.value) + "px, " + (perimeter.value) + "px"),
      strokeDashoffset: strokeDashoffset.value
    }
  });
  return trailPathStyle
};

var useCirclePathStyle = function (perimeter, rate, percentage, strokeDashoffset) {
  var circlePathStyle = computed(function () {
    return {
      strokeDasharray: ((perimeter.value * rate.value * (percentage.value / 100)) + "px, " + (perimeter.value) + "px"),
      strokeDashoffset: strokeDashoffset.value,
      transition: 'stroke-dasharray 0.6s ease 0s, stroke 0.6s ease'
    }
  });
  return circlePathStyle
};

var useStroke = function (color, getCurrentColor, percentage, status) {
  var stroke = computed(function () {
    var statusValue = status && status.value;
    var ret;
    if (color.value) {
      ret = getCurrentColor(percentage.value);
    } else {
      switch (statusValue) {
        case 'success':
          ret = '#13ce66';
          break
        case 'exception':
          ret = '#ff4949';
          break
        case 'warning':
          ret = '#e6a23c';
          break
        default:
          ret = '#20a0ff';
      }
    }
    return ret
  });
  return stroke
};

var useIconClass = function (status, type) {
  var iconClass = computed(function () {
    if (status.value === 'warning') {
      return 'el-icon-warning'
    }
    if (type.value === 'line') {
      return status.value === 'success'
        ? 'el-icon-circle-check'
        : 'el-icon-circle-close'
    } else {
      return status.value === 'success' ? 'el-icon-check' : 'el-icon-close'
    }
  });
  return iconClass
};

var useProgressTextSize = function (type, strokeWidth, width) {
  var progressTextSize = computed(function () {
    return type.value === 'line'
      ? 12 + strokeWidth.value * 0.4
      : width.value * 0.111111 + 2
  });
  return progressTextSize
};

var useContent = function (format, percentage) {
  var content = computed(function () {
    if (format && typeof format.value === 'function') {
      return format.value(percentage.value) || ''
    } else {
      return ((percentage.value) + "%")
    }
  });
  return content
};

var _hoisted_1$3 = {
  key: 0,
  class: "el-progress-bar"
};
var _hoisted_2$2 = {
  key: 0,
  class: "el-progress-bar__innerText"
};
var _hoisted_3$1 = { viewBox: "0 0 100 100" };

function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: ["el-progress", [
      'el-progress--' + _ctx.type,
      _ctx.status ? 'is-' + _ctx.status : '',
      {
        'el-progress--without-text': !_ctx.showText,
        'el-progress--text-inside': _ctx.textInside
      }
    ]],
    role: "progressbar",
    "aria-valuenow": _ctx.percentage,
    "aria-valuemin": "0",
    "aria-valuemax": "100"
  }, [
    (_ctx.type === 'line')
      ? (openBlock(), createBlock("div", _hoisted_1$3, [
          createVNode("div", {
            class: "el-progress-bar__outer",
            style: { height: _ctx.strokeWidth + 'px' }
          }, [
            createVNode("div", {
              class: "el-progress-bar__inner",
              style: _ctx.barStyle
            }, [
              (_ctx.showText && _ctx.textInside)
                ? (openBlock(), createBlock("div", _hoisted_2$2, toDisplayString(_ctx.content), 1 /* TEXT */))
                : createCommentVNode("v-if", true)
            ], 4 /* STYLE */)
          ], 4 /* STYLE */)
        ]))
      : (openBlock(), createBlock("div", {
          key: 1,
          class: "el-progress-circle",
          style: { height: _ctx.width + 'px', width: _ctx.width + 'px' }
        }, [
          (openBlock(), createBlock("svg", _hoisted_3$1, [
            createVNode("path", {
              class: "el-progress-circle__track",
              d: _ctx.trackPath,
              stroke: "#e5e9f2",
              "stroke-width": _ctx.relativeStrokeWidth,
              fill: "none",
              style: _ctx.trailPathStyle
            }, null, 12 /* STYLE, PROPS */, ["d", "stroke-width"]),
            createVNode("path", {
              class: "el-progress-circle__path",
              d: _ctx.trackPath,
              stroke: _ctx.stroke,
              fill: "none",
              "stroke-linecap": _ctx.strokeLinecap,
              "stroke-width": _ctx.percentage ? _ctx.relativeStrokeWidth : 0,
              style: _ctx.circlePathStyle
            }, null, 12 /* STYLE, PROPS */, ["d", "stroke", "stroke-linecap", "stroke-width"])
          ]))
        ], 4 /* STYLE */)),
    (_ctx.showText && !_ctx.textInside)
      ? (openBlock(), createBlock("div", {
          key: 2,
          class: "el-progress__text",
          style: { fontSize: _ctx.progressTextSize + 'px' }
        }, [
          (!_ctx.status)
            ? (openBlock(), createBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(_ctx.content), 1 /* TEXT */)
              ], 64 /* STABLE_FRAGMENT */))
            : (openBlock(), createBlock("i", {
                key: 1,
                class: _ctx.iconClass
              }, null, 2 /* CLASS */))
        ], 4 /* STYLE */))
      : createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, ["aria-valuenow"]))
}

script$5.render = render$5;
script$5.__file = "packages/progress/Progress.vue";

script$5.install = function (app) {
  app.component(script$5.name, script$5);
};

var script$6 = {
  name: 'ElLink',

  props: {
    type: {
      type: String,
      default: 'default'
    },
    underline: {
      type: Boolean,
      default: true
    },
    disabled: Boolean,
    href: String,
    icon: String
  },

  setup: function setup(props, ref) {
    var emit = ref.emit;

    var handleClick = function (evt) {
      if (props.disabled) { return }
      if (props.href) { return }

      emit('click', evt);
    };

    return {
      handleClick: handleClick
    }
  }
};

var _hoisted_1$4 = {
  key: 1,
  class: "el-link--inner"
};

function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("a", mergeProps({
    class: [
      'el-link',
      _ctx.type ? ("el-link--" + (_ctx.type)) : '',
      _ctx.disabled && 'is-disabled',
      _ctx.underline && !_ctx.disabled && 'is-underline'
    ],
    href: _ctx.disabled ? null : _ctx.href
  }, _ctx.$attrs, {
    onClick: _cache[1] || (_cache[1] = function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      return (_ctx.handleClick.apply(_ctx, args));
  })
  }), [
    (_ctx.icon)
      ? (openBlock(), createBlock("i", {
          key: 0,
          class: _ctx.icon
        }, null, 2 /* CLASS */))
      : createCommentVNode("v-if", true),
    (_ctx.$slots.default)
      ? (openBlock(), createBlock("span", _hoisted_1$4, [
          renderSlot(_ctx.$slots, "default")
        ]))
      : createCommentVNode("v-if", true),
    (_ctx.$slots.icon)
      ? renderSlot(_ctx.$slots, "icon", { key: 2 })
      : createCommentVNode("v-if", true)
  ], 16 /* FULL_PROPS */, ["href"]))
}

script$6.render = render$6;
script$6.__file = "packages/link/Link.vue";

/* istanbul ignore next */
script$6.install = function (app) {
  app.component(script$6.name, script$6);
};

var script$7 = {
  name: 'ElIcon',

  props: {
    name: String
  }
};

function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("i", {
    class: ("el-icon-" + (_ctx.name))
  }, null, 2 /* CLASS */))
}

script$7.render = render$7;
script$7.__file = "packages/icon/Icon.vue";

/* istanbul ignore next */
script$7.install = function (app) {
  app.component(script$7.name, script$7);
};

var script$8 = {
  name: 'ElBreadcrumb',
  props: {
    separator: {
      type: String,
      default: '/'
    },
    separatorClass: {
      type: String,
      default: ''
    }
  },
  setup: function setup(props) {
    var ref$1 = toRefs(props);
    var separator = ref$1.separator;
    var separatorClass = ref$1.separatorClass;
    var root = ref(null);
    provide('separator', separator);
    provide('separatorClass', separatorClass);
    onMounted(function () {
      var items = root.value.querySelectorAll('.el-breadcrumb__item');
      if (items.length) {
        items[items.length - 1].setAttribute('aria-current', 'page');
      }
    });
    return {
      root: root
    }
  }
};

var _hoisted_1$5 = {
  ref: "root",
  class: "el-breadcrumb",
  "aria-label": "Breadcrumb",
  role: "navigation"
};

function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", _hoisted_1$5, [
    renderSlot(_ctx.$slots, "default")
  ], 512 /* NEED_PATCH */))
}

script$8.render = render$8;
script$8.__file = "packages/breadcrumb/Breadcrumb.vue";

/* istanbul ignore next */
script$8.install = function (app) {
  app.component(script$8.name, script$8);
};

var script$9 = {
  name: 'ElBreadcrumbItem',
  props: {
    to: {},
    replace: Boolean
  },
  setup: function setup(props) {
    var ref$1 = toRefs(props);
    var replace = ref$1.replace;
    var separator = inject('separator');
    var separatorClass = inject('separatorClass');
    var link = ref(null);
    var ref$2 = getCurrentInstance();
    var ctx = ref$2.ctx;
    onMounted(function () {
      link.value.setAttribute('role', 'link');
      link.value.addEventListener('click', function () {
        if (!props.to || !ctx.$router) { return }
        replace ? ctx.$router.replace(props.to) : ctx.$router.push(props.to);
      });
    });
    return {
      separator: separator,
      separatorClass: separatorClass,
      link: link
    }
  }
};

var _hoisted_1$6 = { class: "el-breadcrumb__item" };
var _hoisted_2$3 = {
  key: 1,
  class: "el-breadcrumb__separator",
  role: "presentation"
};

function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("span", _hoisted_1$6, [
    createVNode("span", {
      class: ['el-breadcrumb__inner', _ctx.to ? 'is-link' : ''],
      ref: "link",
      role: "link"
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2 /* CLASS */),
    (_ctx.separatorClass)
      ? (openBlock(), createBlock("i", {
          key: 0,
          class: ["el-breadcrumb__separator", _ctx.separatorClass]
        }, null, 2 /* CLASS */))
      : (openBlock(), createBlock("span", _hoisted_2$3, toDisplayString(_ctx.separator), 1 /* TEXT */))
  ]))
}

script$9.render = render$9;
script$9.__file = "packages/breadcrumb/BreadcrumbItem.vue";

/* istanbul ignore next */
script$9.install = function (app) {
  app.component(script$9.name, script$9);
};

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset)
 * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @return {Function}  A new, throttled, function.
 */
var throttle = function ( delay, noTrailing, callback, debounceMode ) {

	// After wrapper has stopped being called, this timeout ensures that
	// `callback` is executed at the proper times in `throttle` and `end`
	// debounce modes.
	var timeoutID;

	// Keep track of the last time `callback` was executed.
	var lastExec = 0;

	// `noTrailing` defaults to falsy.
	if ( typeof noTrailing !== 'boolean' ) {
		debounceMode = callback;
		callback = noTrailing;
		noTrailing = undefined;
	}

	// The `wrapper` function encapsulates all of the throttling / debouncing
	// functionality and when executed will limit the rate at which `callback`
	// is executed.
	function wrapper () {

		var self = this;
		var elapsed = Number(new Date()) - lastExec;
		var args = arguments;

		// Execute `callback` and update the `lastExec` timestamp.
		function exec () {
			lastExec = Number(new Date());
			callback.apply(self, args);
		}

		// If `debounceMode` is true (at begin) this is used to clear the flag
		// to allow future `callback` executions.
		function clear () {
			timeoutID = undefined;
		}

		if ( debounceMode && !timeoutID ) {
			// Since `wrapper` is being called for the first time and
			// `debounceMode` is true (at begin), execute `callback`.
			exec();
		}

		// Clear any existing timeout.
		if ( timeoutID ) {
			clearTimeout(timeoutID);
		}

		if ( debounceMode === undefined && elapsed > delay ) {
			// In throttle mode, if `delay` time has been exceeded, execute
			// `callback`.
			exec();

		} else if ( noTrailing !== true ) {
			// In trailing throttle mode, since `delay` time has not been
			// exceeded, schedule `callback` to execute `delay` ms after most
			// recent execution.
			//
			// If `debounceMode` is true (at begin), schedule `clear` to execute
			// after `delay` ms.
			//
			// If `debounceMode` is false (at end), schedule `callback` to
			// execute after `delay` ms.
			timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
		}

	}

	// Return the wrapper function.
	return wrapper;

};

var cubic = function (value) { return Math.pow(value, 3); };
var easeInOutCubic = function (value) { return value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2; };

var script$a = {
  name: 'ElBacktop',
  components: {
    ElIcon: ElIcon
  },
  props: {
    visibilityHeight: {
      type: Number,
      default: 200
    },
    target: {
      type: String,
      default: null
    },
    right: {
      type: Number,
      default: 40
    },
    bottom: {
      type: Number,
      default: 40
    }
  },

  setup: function setup(props, ref$1) {
    var emit = ref$1.emit;

    var el = ref(null);
    var container = ref(null);
    var visible = ref(null);
    var throttledScrollHandler;

    var ref$2 = toRefs(props);
    var visibilityHeight = ref$2.visibilityHeight;
    var target = ref$2.target;
    var right = ref$2.right;
    var bottom = ref$2.bottom;

    var styleBottom = computed(function () { return ((bottom.value) + "px"); });
    var styleRight = computed(function () { return ((right.value) + "px"); });

    var init = function () {
      container.value = document;
      el.value = document.documentElement;
      if (target.value) {
        el.value = document.querySelector(target.value);
        if (!el.value) {
          throw new Error(("target is not existed: " + (target.value)))
        }
        container.value = el.value;
      }
    };

    var onScroll = function () {
      var scrollTop = el.value.scrollTop;
      visible.value = scrollTop >= visibilityHeight.value;
    };

    var handleClick = function (e) {
      scrollToTop();
      emit('click', e);
    };

    var scrollToTop = function () {
      var element = el.value;
      var beginTime = Date.now();
      var beginValue = element.scrollTop;
      var rAF =
        window.requestAnimationFrame || (function (func) { return setTimeout(func, 16); });
      var frameFunc = function () {
        var progress = (Date.now() - beginTime) / 500;
        if (progress < 1) {
          element.scrollTop = beginValue * (1 - easeInOutCubic(progress));
          rAF(frameFunc);
        } else {
          element.scrollTop = 0;
        }
      };
      rAF(frameFunc);
    };

    onMounted(function () {
      init();
      throttledScrollHandler = throttle(300, onScroll);
      container.value.addEventListener('scroll', throttledScrollHandler);
    });

    onUnmounted(function () {
      container.value.removeEventListener('scroll', throttledScrollHandler);
    });

    return {
      visible: visible,
      styleBottom: styleBottom,
      styleRight: styleRight,
      handleClick: handleClick
    }
  }
};

function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_el_icon = resolveComponent("el-icon");

  return (openBlock(), createBlock(Transition, { name: "el-fade-in" }, {
    default: withCtx(function () { return [
      (_ctx.visible)
        ? (openBlock(), createBlock("div", {
            key: 0,
            onClick: _cache[1] || (_cache[1] = withModifiers(function () {
              var args = [], len = arguments.length;
              while ( len-- ) args[ len ] = arguments[ len ];

              return (_ctx.handleClick.apply(_ctx, args));
      }, ["stop"])),
            style: {
        right: _ctx.styleRight,
        bottom: _ctx.styleBottom
      },
            class: "el-backtop"
          }, [
            renderSlot(_ctx.$slots, "default", {}, function () { return [
              createVNode(_component_el_icon, { name: "caret-top" })
            ]; })
          ], 4 /* STYLE */))
        : createCommentVNode("v-if", true)
    ]; }),
    _: 1
  }))
}

script$a.render = render$a;
script$a.__file = "packages/backtop/Backtop.vue";

/* istanbul ignore next */
script$a.install = function (app) {
  app.component(script$a.name, script$a);
};

var version = "0.0.12";

// 用于构建时的入口

var components = [
  script,
  script$1,
  script$2,
  script$4,
  script$5,
  script$6,
  script$7,
  script$8,
  script$9,
  script$a
];

var install = function (app) {
  components.forEach(function (component) {
    app.component(component.name, component);
  });
};

var elementUI = {
  version: version,
  install: install
};

export default elementUI;
export { script as ElAlert, script$a as ElBacktop, script$8 as ElBreadcrumb, script$9 as ElBreadcrumbItem, script$2 as ElButton, script$1 as ElContainer, script$7 as ElIcon, script$6 as ElLink, script$5 as ElProgress, script$4 as ElSwitch };
