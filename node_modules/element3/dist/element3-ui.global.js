/*!
  * element3 v0.0.12
  * (c) 2020 kkb
  * @license MIT
  */
var Element3 = (function (exports, vue, ElIcon) {
  'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }

  var ElIcon__default = /*#__PURE__*/_interopDefaultLegacy(ElIcon);

  var TYPE_CLASSES_MAP = {
    success: 'el-icon-success',
    warning: 'el-icon-warning',
    error: 'el-icon-error'
  };
  var script = {
    name: 'ElAlert',
    props: {
      title: {
        type: String,
        default: ''
      },
      description: {
        type: String,
        default: ''
      },
      type: {
        type: String,
        default: 'info'
      },
      closable: {
        type: Boolean,
        default: true
      },
      closeText: {
        type: String,
        default: ''
      },
      showIcon: Boolean,
      center: Boolean,
      effect: {
        type: String,
        default: 'light',
        validator: function (value) {
          return ['light', 'dark'].indexOf(value) !== -1
        }
      }
    },
    emits: ['close'],
    setup: function setup(props, ref$1) {
      var emit = ref$1.emit;
      var slots = ref$1.slots;

      var ref$2 = vue.toRefs(props);
      var description = ref$2.description;
      var type = ref$2.type;

      var visible = vue.ref(true);
      var close = function () {
        visible.value = false;
        emit('close');
      };

      var typeClass = vue.computed(function () {
        return ("el-alert--" + (type.value))
      });

      var iconClass = vue.computed(function () {
        return TYPE_CLASSES_MAP[type.value] || 'el-icon-info'
      });

      var isBigIcon = vue.computed(function () {
        return description.value || slots.default ? 'is-big' : ''
      });

      var isBoldTitle = vue.computed(function () {
        return description.value || slots.default ? 'is-bold' : ''
      });

      return {
        visible: visible,
        typeClass: typeClass,
        iconClass: iconClass,
        isBigIcon: isBigIcon,
        isBoldTitle: isBoldTitle,
        close: close
      }
    }
  };

  var _hoisted_1 = { class: "el-alert__content" };
  var _hoisted_2 = {
    key: 1,
    class: "el-alert__description"
  };
  var _hoisted_3 = {
    key: 2,
    class: "el-alert__description"
  };

  function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createBlock(vue.Transition, { name: "el-alert-fade" }, {
      default: vue.withCtx(function () { return [
        vue.withDirectives(vue.createVNode("div", {
          class: ["el-alert", [_ctx.typeClass, _ctx.center ? 'is-center' : '', 'is-' + _ctx.effect]],
          role: "alert"
        }, [
          (_ctx.showIcon)
            ? (vue.openBlock(), vue.createBlock("i", {
                key: 0,
                class: ["el-alert__icon", [_ctx.iconClass, _ctx.isBigIcon]]
              }, null, 2 /* CLASS */))
            : vue.createCommentVNode("v-if", true),
          vue.createVNode("div", _hoisted_1, [
            (_ctx.title || _ctx.$slots.title)
              ? (vue.openBlock(), vue.createBlock("span", {
                  key: 0,
                  class: ["el-alert__title", [_ctx.isBoldTitle]]
                }, [
                  vue.renderSlot(_ctx.$slots, "title", {}, function () { return [
                    vue.createTextVNode(vue.toDisplayString(_ctx.title), 1 /* TEXT */)
                  ]; })
                ], 2 /* CLASS */))
              : vue.createCommentVNode("v-if", true),
            (_ctx.$slots.default && !_ctx.description)
              ? (vue.openBlock(), vue.createBlock("p", _hoisted_2, [
                  vue.renderSlot(_ctx.$slots, "default")
                ]))
              : vue.createCommentVNode("v-if", true),
            (_ctx.description && !_ctx.$slots.default)
              ? (vue.openBlock(), vue.createBlock("p", _hoisted_3, vue.toDisplayString(_ctx.description), 1 /* TEXT */))
              : vue.createCommentVNode("v-if", true),
            vue.withDirectives(vue.createVNode("i", {
              class: ["el-alert__closebtn", {
              'is-customed': _ctx.closeText !== '',
              'el-icon-close': _ctx.closeText === ''
            }],
              onClick: _cache[1] || (_cache[1] = function () {
                var args = [], len = arguments.length;
                while ( len-- ) args[ len ] = arguments[ len ];

                return (_ctx.close.apply(_ctx, args));
        })
            }, vue.toDisplayString(_ctx.closeText), 3 /* TEXT, CLASS */), [
              [vue.vShow, _ctx.closable]
            ])
          ])
        ], 2 /* CLASS */), [
          [vue.vShow, _ctx.visible]
        ])
      ]; }),
      _: 1
    }))
  }

  script.render = render;
  script.__file = "packages/alert/Alert.vue";

  /* istanbul ignore next */
  script.install = function (app) {
    app.component(script.name, script);
  };

  var script$1 = {
    name: 'ElContainer',
    props: {
      direction: String
    },
    setup: function setup(props, ref) {
      var slots = ref.slots;

      var ref$1 = vue.toRefs(props);
      var direction = ref$1.direction;

      var isVertical = vue.computed(function () {
        if (direction === 'vertical') {
          return true
        } else if (direction === 'horizontal') {
          return false
        }
        if (slots && slots.default) {
          return slots.default().some(function (vNode) {
            var tag = vNode.type && vNode.type.name;
            return tag === 'ElHeader' || tag === 'ElFooter'
          })
        } else {
          return false
        }
      });
      return {
        isVertical: isVertical
      }
    }
  };

  function render$1(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createBlock("section", {
      class: ["el-container", { 'is-vertical': _ctx.isVertical }]
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2 /* CLASS */))
  }

  script$1.render = render$1;
  script$1.__file = "packages/container/Container.vue";

  /* istanbul ignore next */
  script$1.install = function (app) {
    app.component(script$1.name, script$1);
  };

  var script$2 = {
    name: 'ElButton',

    props: {
      type: {
        type: String,
        default: 'default'
      },
      size: {
        type: String,
        default: ''
      },
      icon: {
        type: String,
        default: ''
      },
      nativeType: {
        type: String,
        default: 'button'
      },
      loading: Boolean,
      disabled: Boolean,
      plain: Boolean,
      autofocus: Boolean,
      round: Boolean,
      circle: Boolean
    },
    emits: ['click'],
    setup: function setup(props, ctx) {
      var ref = vue.toRefs(props);
      var size = ref.size;
      var disabled = ref.disabled;

      var buttonSize = useButtonSize(size);
      var buttonDisabled = useButtonDisabled(disabled);

      var handleClick = function (evt) {
        ctx.emit('click', evt);
      };

      return {
        handleClick: handleClick,
        buttonSize: buttonSize,
        buttonDisabled: buttonDisabled
      }
    }
  };

  var useButtonSize = function (size) {
    var elFormItem = vue.inject('elFormItem', {});

    var _elFormItemSize = vue.computed(function () {
      return vue.unref(elFormItem.elFormItemSize)
    });

    var buttonSize = vue.computed(function () {
      return (
        size.value ||
        _elFormItemSize.value ||
        (vue.getCurrentInstance().proxy.$ELEMENT || {}).size
      )
    });

    return buttonSize
  };

  var useButtonDisabled = function (disabled) {
    var elForm = vue.inject('elForm', {});

    var buttonDisabled = vue.computed(function () {
      return disabled.value || vue.unref(elForm.disabled)
    });

    return buttonDisabled
  };

  var _hoisted_1$1 = {
    key: 0,
    class: "el-icon-loading"
  };
  var _hoisted_2$1 = { key: 2 };

  function render$2(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createBlock("button", {
      class: ["el-button", [
        _ctx.type ? 'el-button--' + _ctx.type : '',
        _ctx.buttonSize ? 'el-button--' + _ctx.buttonSize : '',
        {
          'is-disabled': _ctx.buttonDisabled,
          'is-loading': _ctx.loading,
          'is-plain': _ctx.plain,
          'is-round': _ctx.round,
          'is-circle': _ctx.circle
        }
      ]],
      onClick: _cache[1] || (_cache[1] = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return (_ctx.handleClick.apply(_ctx, args));
    }),
      disabled: _ctx.buttonDisabled || _ctx.loading,
      autofocus: _ctx.autofocus,
      type: _ctx.nativeType
    }, [
      (_ctx.loading)
        ? (vue.openBlock(), vue.createBlock("i", _hoisted_1$1))
        : vue.createCommentVNode("v-if", true),
      (_ctx.icon && !_ctx.loading)
        ? (vue.openBlock(), vue.createBlock("i", {
            key: 1,
            class: _ctx.icon
          }, null, 2 /* CLASS */))
        : vue.createCommentVNode("v-if", true),
      (_ctx.$slots.default)
        ? (vue.openBlock(), vue.createBlock("span", _hoisted_2$1, [
            vue.renderSlot(_ctx.$slots, "default")
          ]))
        : vue.createCommentVNode("v-if", true)
    ], 10 /* CLASS, PROPS */, ["disabled", "autofocus", "type"]))
  }

  script$2.render = render$2;
  script$2.__file = "packages/button/Button.vue";

  /* istanbul ignore next */
  script$2.install = function (app) {
    app.component(script$2.name, script$2);
  };

  var script$3 = {
    props: {
      type: {
        type: String
      },
      active: {
        type: Boolean,
        default: false
      },
      text: {
        type: String,
        default: ''
      },
      iconClass: {
        type: String,
        default: ''
      }
    }
  };

  var _hoisted_1$2 = { key: 0 };

  function render$3(_ctx, _cache, $props, $setup, $data, $options) {
    var obj;

    return (_ctx.iconClass || _ctx.text)
      ? (vue.openBlock(), vue.createBlock("span", {
          key: 0,
          class: ( obj = {
        'el-switch__label': true,
        'is-active': _ctx.active
      }, obj[("el-switch__label--" + (_ctx.type))] = true, obj )
        }, [
          vue.createVNode("i", {
            class: [_ctx.iconClass]
          }, null, 2 /* CLASS */),
          (!_ctx.iconClass)
            ? (vue.openBlock(), vue.createBlock("span", _hoisted_1$2, vue.toDisplayString(_ctx.text), 1 /* TEXT */))
            : vue.createCommentVNode("v-if", true)
        ], 2 /* CLASS */))
      : vue.createCommentVNode("v-if", true)
  }

  script$3.render = render$3;
  script$3.__file = "packages/switch/SwitchLabel.vue";

  var script$4 = {
    name: 'ElSwitch',
    components: {
      SwitchLabel: script$3
    },
    props: {
      modelValue: {
        type: [Boolean, String, Number],
        default: false
      },
      activeValue: {
        type: [Boolean, String, Number],
        default: true
      },
      inactiveValue: {
        type: [Boolean, String, Number],
        default: false
      },
      disabled: {
        type: Boolean,
        default: false
      },
      width: {
        type: Number,
        default: 40
      },
      activeText: String,
      inactiveText: String,
      activeIconClass: {
        type: String,
        default: ''
      },
      inactiveIconClass: {
        type: String,
        default: ''
      },
      activeColor: {
        type: String,
        default: ''
      },
      inactiveColor: {
        type: String,
        default: ''
      }
    },
    emits: ['update:modelValue', 'change'],
    setup: function setup(props, ref) {
      var emit = ref.emit;

      var ref$1 = vue.toRefs(props);
      var activeValue = ref$1.activeValue;
      var inactiveValue = ref$1.inactiveValue;
      var modelValue = ref$1.modelValue;
      var disabled = ref$1.disabled;
      var activeColor = ref$1.activeColor;
      var inactiveColor = ref$1.inactiveColor;

      useNormalizeModelValue({
        modelValue: modelValue,
        activeValue: activeValue,
        inactiveValue: inactiveValue,
        emit: emit
      });

      var isChecked = vue.computed(function () {
        return modelValue.value === activeValue.value
      });

      var backgroundColor = vue.computed(function () {
        return isChecked.value ? activeColor.value : inactiveColor.value
      });

      var ref$2 = useClick({
        isChecked: isChecked,
        inactiveValue: inactiveValue,
        activeValue: activeValue,
        disabled: disabled,
        emit: emit
      });
      var handleClick = ref$2.handleClick;

      return {
        isChecked: isChecked,
        backgroundColor: backgroundColor,
        handleClick: handleClick
      }
    }
  };

  var useNormalizeModelValue = function (ref) {
    var modelValue = ref.modelValue;
    var activeValue = ref.activeValue;
    var inactiveValue = ref.inactiveValue;
    var emit = ref.emit;

    vue.onMounted(function () {
      if (
        modelValue.value !== activeValue.value &&
        modelValue.value !== inactiveValue.value
      ) {
        emit('update:modelValue', inactiveValue.value);
      }
    });
  };

  var useClick = function (ref) {
    var isChecked = ref.isChecked;
    var inactiveValue = ref.inactiveValue;
    var activeValue = ref.activeValue;
    var disabled = ref.disabled;
    var emit = ref.emit;

    var getNewValue = function () {
      return isChecked.value ? inactiveValue.value : activeValue.value
    };

    var handleClick = function () {
      if (disabled.value) { return }

      var newValue = getNewValue();
      emit('update:modelValue', newValue);
      emit('change', newValue);
    };

    return {
      handleClick: handleClick
    }
  };

  function render$4(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_SwitchLabel = vue.resolveComponent("SwitchLabel");

    return (vue.openBlock(), vue.createBlock("div", {
      class: ["el-switch", { 'is-checked': _ctx.isChecked, 'is-disabled': _ctx.disabled }],
      onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return (_ctx.handleClick.apply(_ctx, args));
    }, ["prevent"]))
    }, [
      vue.createVNode(_component_SwitchLabel, {
        active: !_ctx.isChecked,
        type: "left",
        text: _ctx.inactiveText,
        iconClass: _ctx.inactiveIconClass
      }, null, 8 /* PROPS */, ["active", "text", "iconClass"]),
      vue.createVNode("span", {
        class: "el-switch__core",
        ref: "core",
        style: {
          width: _ctx.width + 'px',
          background: _ctx.backgroundColor,
          'border-color': _ctx.backgroundColor
        }
      }, null, 4 /* STYLE */),
      vue.createVNode(_component_SwitchLabel, {
        active: _ctx.isChecked,
        type: "right",
        text: _ctx.activeText,
        iconClass: _ctx.activeIconClass
      }, null, 8 /* PROPS */, ["active", "text", "iconClass"])
    ], 2 /* CLASS */))
  }

  script$4.render = render$4;
  script$4.__file = "packages/switch/Switch.vue";

  /* istanbul ignore next */
  script$4.install = function (app) {
    app.component(script$4.name, script$4);
  };

  var script$5 = {
    name: 'ElProgress',
    props: {
      type: {
        type: String,
        default: 'line',
        validator: function (val) { return ['line', 'circle', 'dashboard'].indexOf(val) > -1; }
      },
      percentage: {
        type: Number,
        default: 0,
        required: true,
        validator: function (val) { return val >= 0 && val <= 100; }
      },
      status: {
        type: String,
        validator: function (val) { return ['success', 'exception', 'warning'].indexOf(val) > -1; }
      },
      strokeWidth: {
        type: Number,
        default: 6
      },
      strokeLinecap: {
        type: String,
        default: 'round'
      },
      textInside: {
        type: Boolean,
        default: false
      },
      width: {
        type: Number,
        default: 126
      },
      showText: {
        type: Boolean,
        default: true
      },
      color: {
        type: [String, Array, Function],
        default: ''
      },
      format: Function
    },
    setup: function setup(props) {
      var ref = vue.toRefs(props);
      var percentage = ref.percentage;
      var color = ref.color;
      var strokeWidth = ref.strokeWidth;
      var width = ref.width;
      var type = ref.type;
      var status = ref.status;
      var format = ref.format;

      var getCurrentColor = function (percentage) {
        if (typeof color.value === 'function') {
          return color.value(percentage)
        } else if (typeof color.value === 'string') {
          return color.value
        } else {
          return getLevelColor(percentage)
        }
      };

      var getLevelColor = function (percentage) {
        var colorArray = getColorArray().sort(
          function (a, b) { return a.percentage - b.percentage; }
        );

        for (var i = 0; i < colorArray.length; i++) {
          if (colorArray[i].percentage > percentage) {
            return colorArray[i].color
          }
        }
        return colorArray[colorArray.length - 1].color
      };

      var getColorArray = function () {
        var span = 100 / color.value.length;
        return color.value.map(function (seriesColor, index) {
          if (typeof seriesColor === 'string') {
            return {
              color: seriesColor,
              progress: (index + 1) * span
            }
          }
          return seriesColor
        })
      };

      var barStyle = useBarStyle(percentage, getCurrentColor);
      var relativeStrokeWidth = useRelativeStrokeWidth(strokeWidth, width);
      var radius = useRadius(type, relativeStrokeWidth);
      var trackPath = useTrackPath(radius, type);
      var perimeter = usePerimeter(radius);
      var rate = useRate(type);
      var strokeDashoffset = useStrokeDashoffset(perimeter, rate);
      var trailPathStyle = useTrailPathStyle(perimeter, rate, strokeDashoffset);
      var circlePathStyle = useCirclePathStyle(
        perimeter,
        rate,
        percentage,
        strokeDashoffset
      );
      var stroke = useStroke(color, getCurrentColor, percentage, status);
      var iconClass = useIconClass(status, type);
      var progressTextSize = useProgressTextSize(type, strokeWidth, width);
      var content = useContent(format, percentage);

      return {
        barStyle: barStyle,
        relativeStrokeWidth: relativeStrokeWidth,
        trackPath: trackPath,
        trailPathStyle: trailPathStyle,
        circlePathStyle: circlePathStyle,
        stroke: stroke,
        iconClass: iconClass,
        progressTextSize: progressTextSize,
        content: content
      }
    }
  };

  var useBarStyle = function (percentage, getCurrentColor) {
    var barStyle = vue.computed(function () {
      var style = {};
      style.width = percentage.value + '%';
      style.backgroundColor = getCurrentColor(percentage.value);
      return style
    });
    return barStyle
  };

  var useRelativeStrokeWidth = function (strokeWidth, width) {
    var relativeStrokeWidth = vue.computed(function () {
      return ((strokeWidth.value / width.value) * 100).toFixed(1)
    });
    return relativeStrokeWidth
  };

  var useRadius = function (type, relativeStrokeWidth) {
    var radius = vue.computed(function () {
      if (type.value === 'circle' || type.value === 'dashboard') {
        return parseInt(50 - parseFloat(relativeStrokeWidth.value) / 2, 10)
      } else {
        return 0
      }
    });
    return radius
  };

  var useTrackPath = function (radius, type) {
    var trackPath = vue.computed(function () {
      var isDashboard = type.value === 'dashboard';
      return ("\n          M 50 50\n          m 0 " + (isDashboard ? '' : '-') + (radius.value) + "\n          a " + (radius.value) + " " + (radius.value) + " 0 1 1 0 " + (isDashboard ? '-' : '') + (radius.value * 2) + "\n          a " + (radius.value) + " " + (radius.value) + " 0 1 1 0 " + (isDashboard ? '' : '-') + (radius.value * 2) + "\n          ")
    });
    return trackPath
  };

  var usePerimeter = function (radius) {
    var perimeter = vue.computed(function () {
      return 2 * Math.PI * radius.value
    });
    return perimeter
  };

  var useRate = function (type) {
    var rate = vue.computed(function () {
      return type.value === 'dashboard' ? 0.75 : 1
    });
    return rate
  };

  var useStrokeDashoffset = function (perimeter, rate) {
    var strokeDashoffset = vue.computed(function () {
      var offset = (-1 * perimeter.value * (1 - rate.value)) / 2;
      return (offset + "px")
    });
    return strokeDashoffset
  };

  var useTrailPathStyle = function (perimeter, rate, strokeDashoffset) {
    var trailPathStyle = vue.computed(function () {
      return {
        strokeDasharray: ((perimeter.value * rate.value) + "px, " + (perimeter.value) + "px"),
        strokeDashoffset: strokeDashoffset.value
      }
    });
    return trailPathStyle
  };

  var useCirclePathStyle = function (perimeter, rate, percentage, strokeDashoffset) {
    var circlePathStyle = vue.computed(function () {
      return {
        strokeDasharray: ((perimeter.value * rate.value * (percentage.value / 100)) + "px, " + (perimeter.value) + "px"),
        strokeDashoffset: strokeDashoffset.value,
        transition: 'stroke-dasharray 0.6s ease 0s, stroke 0.6s ease'
      }
    });
    return circlePathStyle
  };

  var useStroke = function (color, getCurrentColor, percentage, status) {
    var stroke = vue.computed(function () {
      var statusValue = status && status.value;
      var ret;
      if (color.value) {
        ret = getCurrentColor(percentage.value);
      } else {
        switch (statusValue) {
          case 'success':
            ret = '#13ce66';
            break
          case 'exception':
            ret = '#ff4949';
            break
          case 'warning':
            ret = '#e6a23c';
            break
          default:
            ret = '#20a0ff';
        }
      }
      return ret
    });
    return stroke
  };

  var useIconClass = function (status, type) {
    var iconClass = vue.computed(function () {
      if (status.value === 'warning') {
        return 'el-icon-warning'
      }
      if (type.value === 'line') {
        return status.value === 'success'
          ? 'el-icon-circle-check'
          : 'el-icon-circle-close'
      } else {
        return status.value === 'success' ? 'el-icon-check' : 'el-icon-close'
      }
    });
    return iconClass
  };

  var useProgressTextSize = function (type, strokeWidth, width) {
    var progressTextSize = vue.computed(function () {
      return type.value === 'line'
        ? 12 + strokeWidth.value * 0.4
        : width.value * 0.111111 + 2
    });
    return progressTextSize
  };

  var useContent = function (format, percentage) {
    var content = vue.computed(function () {
      if (format && typeof format.value === 'function') {
        return format.value(percentage.value) || ''
      } else {
        return ((percentage.value) + "%")
      }
    });
    return content
  };

  var _hoisted_1$3 = {
    key: 0,
    class: "el-progress-bar"
  };
  var _hoisted_2$2 = {
    key: 0,
    class: "el-progress-bar__innerText"
  };
  var _hoisted_3$1 = { viewBox: "0 0 100 100" };

  function render$5(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createBlock("div", {
      class: ["el-progress", [
        'el-progress--' + _ctx.type,
        _ctx.status ? 'is-' + _ctx.status : '',
        {
          'el-progress--without-text': !_ctx.showText,
          'el-progress--text-inside': _ctx.textInside
        }
      ]],
      role: "progressbar",
      "aria-valuenow": _ctx.percentage,
      "aria-valuemin": "0",
      "aria-valuemax": "100"
    }, [
      (_ctx.type === 'line')
        ? (vue.openBlock(), vue.createBlock("div", _hoisted_1$3, [
            vue.createVNode("div", {
              class: "el-progress-bar__outer",
              style: { height: _ctx.strokeWidth + 'px' }
            }, [
              vue.createVNode("div", {
                class: "el-progress-bar__inner",
                style: _ctx.barStyle
              }, [
                (_ctx.showText && _ctx.textInside)
                  ? (vue.openBlock(), vue.createBlock("div", _hoisted_2$2, vue.toDisplayString(_ctx.content), 1 /* TEXT */))
                  : vue.createCommentVNode("v-if", true)
              ], 4 /* STYLE */)
            ], 4 /* STYLE */)
          ]))
        : (vue.openBlock(), vue.createBlock("div", {
            key: 1,
            class: "el-progress-circle",
            style: { height: _ctx.width + 'px', width: _ctx.width + 'px' }
          }, [
            (vue.openBlock(), vue.createBlock("svg", _hoisted_3$1, [
              vue.createVNode("path", {
                class: "el-progress-circle__track",
                d: _ctx.trackPath,
                stroke: "#e5e9f2",
                "stroke-width": _ctx.relativeStrokeWidth,
                fill: "none",
                style: _ctx.trailPathStyle
              }, null, 12 /* STYLE, PROPS */, ["d", "stroke-width"]),
              vue.createVNode("path", {
                class: "el-progress-circle__path",
                d: _ctx.trackPath,
                stroke: _ctx.stroke,
                fill: "none",
                "stroke-linecap": _ctx.strokeLinecap,
                "stroke-width": _ctx.percentage ? _ctx.relativeStrokeWidth : 0,
                style: _ctx.circlePathStyle
              }, null, 12 /* STYLE, PROPS */, ["d", "stroke", "stroke-linecap", "stroke-width"])
            ]))
          ], 4 /* STYLE */)),
      (_ctx.showText && !_ctx.textInside)
        ? (vue.openBlock(), vue.createBlock("div", {
            key: 2,
            class: "el-progress__text",
            style: { fontSize: _ctx.progressTextSize + 'px' }
          }, [
            (!_ctx.status)
              ? (vue.openBlock(), vue.createBlock(vue.Fragment, { key: 0 }, [
                  vue.createTextVNode(vue.toDisplayString(_ctx.content), 1 /* TEXT */)
                ], 64 /* STABLE_FRAGMENT */))
              : (vue.openBlock(), vue.createBlock("i", {
                  key: 1,
                  class: _ctx.iconClass
                }, null, 2 /* CLASS */))
          ], 4 /* STYLE */))
        : vue.createCommentVNode("v-if", true)
    ], 10 /* CLASS, PROPS */, ["aria-valuenow"]))
  }

  script$5.render = render$5;
  script$5.__file = "packages/progress/Progress.vue";

  script$5.install = function (app) {
    app.component(script$5.name, script$5);
  };

  var script$6 = {
    name: 'ElLink',

    props: {
      type: {
        type: String,
        default: 'default'
      },
      underline: {
        type: Boolean,
        default: true
      },
      disabled: Boolean,
      href: String,
      icon: String
    },

    setup: function setup(props, ref) {
      var emit = ref.emit;

      var handleClick = function (evt) {
        if (props.disabled) { return }
        if (props.href) { return }

        emit('click', evt);
      };

      return {
        handleClick: handleClick
      }
    }
  };

  var _hoisted_1$4 = {
    key: 1,
    class: "el-link--inner"
  };

  function render$6(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createBlock("a", vue.mergeProps({
      class: [
        'el-link',
        _ctx.type ? ("el-link--" + (_ctx.type)) : '',
        _ctx.disabled && 'is-disabled',
        _ctx.underline && !_ctx.disabled && 'is-underline'
      ],
      href: _ctx.disabled ? null : _ctx.href
    }, _ctx.$attrs, {
      onClick: _cache[1] || (_cache[1] = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return (_ctx.handleClick.apply(_ctx, args));
    })
    }), [
      (_ctx.icon)
        ? (vue.openBlock(), vue.createBlock("i", {
            key: 0,
            class: _ctx.icon
          }, null, 2 /* CLASS */))
        : vue.createCommentVNode("v-if", true),
      (_ctx.$slots.default)
        ? (vue.openBlock(), vue.createBlock("span", _hoisted_1$4, [
            vue.renderSlot(_ctx.$slots, "default")
          ]))
        : vue.createCommentVNode("v-if", true),
      (_ctx.$slots.icon)
        ? vue.renderSlot(_ctx.$slots, "icon", { key: 2 })
        : vue.createCommentVNode("v-if", true)
    ], 16 /* FULL_PROPS */, ["href"]))
  }

  script$6.render = render$6;
  script$6.__file = "packages/link/Link.vue";

  /* istanbul ignore next */
  script$6.install = function (app) {
    app.component(script$6.name, script$6);
  };

  var script$7 = {
    name: 'ElIcon',

    props: {
      name: String
    }
  };

  function render$7(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createBlock("i", {
      class: ("el-icon-" + (_ctx.name))
    }, null, 2 /* CLASS */))
  }

  script$7.render = render$7;
  script$7.__file = "packages/icon/Icon.vue";

  /* istanbul ignore next */
  script$7.install = function (app) {
    app.component(script$7.name, script$7);
  };

  var script$8 = {
    name: 'ElBreadcrumb',
    props: {
      separator: {
        type: String,
        default: '/'
      },
      separatorClass: {
        type: String,
        default: ''
      }
    },
    setup: function setup(props) {
      var ref$1 = vue.toRefs(props);
      var separator = ref$1.separator;
      var separatorClass = ref$1.separatorClass;
      var root = vue.ref(null);
      vue.provide('separator', separator);
      vue.provide('separatorClass', separatorClass);
      vue.onMounted(function () {
        var items = root.value.querySelectorAll('.el-breadcrumb__item');
        if (items.length) {
          items[items.length - 1].setAttribute('aria-current', 'page');
        }
      });
      return {
        root: root
      }
    }
  };

  var _hoisted_1$5 = {
    ref: "root",
    class: "el-breadcrumb",
    "aria-label": "Breadcrumb",
    role: "navigation"
  };

  function render$8(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createBlock("div", _hoisted_1$5, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 512 /* NEED_PATCH */))
  }

  script$8.render = render$8;
  script$8.__file = "packages/breadcrumb/Breadcrumb.vue";

  /* istanbul ignore next */
  script$8.install = function (app) {
    app.component(script$8.name, script$8);
  };

  var script$9 = {
    name: 'ElBreadcrumbItem',
    props: {
      to: {},
      replace: Boolean
    },
    setup: function setup(props) {
      var ref$1 = vue.toRefs(props);
      var replace = ref$1.replace;
      var separator = vue.inject('separator');
      var separatorClass = vue.inject('separatorClass');
      var link = vue.ref(null);
      var ref$2 = vue.getCurrentInstance();
      var ctx = ref$2.ctx;
      vue.onMounted(function () {
        link.value.setAttribute('role', 'link');
        link.value.addEventListener('click', function () {
          if (!props.to || !ctx.$router) { return }
          replace ? ctx.$router.replace(props.to) : ctx.$router.push(props.to);
        });
      });
      return {
        separator: separator,
        separatorClass: separatorClass,
        link: link
      }
    }
  };

  var _hoisted_1$6 = { class: "el-breadcrumb__item" };
  var _hoisted_2$3 = {
    key: 1,
    class: "el-breadcrumb__separator",
    role: "presentation"
  };

  function render$9(_ctx, _cache, $props, $setup, $data, $options) {
    return (vue.openBlock(), vue.createBlock("span", _hoisted_1$6, [
      vue.createVNode("span", {
        class: ['el-breadcrumb__inner', _ctx.to ? 'is-link' : ''],
        ref: "link",
        role: "link"
      }, [
        vue.renderSlot(_ctx.$slots, "default")
      ], 2 /* CLASS */),
      (_ctx.separatorClass)
        ? (vue.openBlock(), vue.createBlock("i", {
            key: 0,
            class: ["el-breadcrumb__separator", _ctx.separatorClass]
          }, null, 2 /* CLASS */))
        : (vue.openBlock(), vue.createBlock("span", _hoisted_2$3, vue.toDisplayString(_ctx.separator), 1 /* TEXT */))
    ]))
  }

  script$9.render = render$9;
  script$9.__file = "packages/breadcrumb/BreadcrumbItem.vue";

  /* istanbul ignore next */
  script$9.install = function (app) {
    app.component(script$9.name, script$9);
  };

  /* eslint-disable no-undefined,no-param-reassign,no-shadow */

  /**
   * Throttle execution of a function. Especially useful for rate limiting
   * execution of handlers on events like resize and scroll.
   *
   * @param  {Number}    delay          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
   * @param  {Boolean}   [noTrailing]   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
   *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
   *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
   *                                    the internal counter is reset)
   * @param  {Function}  callback       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
   *                                    to `callback` when the throttled-function is executed.
   * @param  {Boolean}   [debounceMode] If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
   *                                    schedule `callback` to execute after `delay` ms.
   *
   * @return {Function}  A new, throttled, function.
   */
  var throttle = function ( delay, noTrailing, callback, debounceMode ) {

  	// After wrapper has stopped being called, this timeout ensures that
  	// `callback` is executed at the proper times in `throttle` and `end`
  	// debounce modes.
  	var timeoutID;

  	// Keep track of the last time `callback` was executed.
  	var lastExec = 0;

  	// `noTrailing` defaults to falsy.
  	if ( typeof noTrailing !== 'boolean' ) {
  		debounceMode = callback;
  		callback = noTrailing;
  		noTrailing = undefined;
  	}

  	// The `wrapper` function encapsulates all of the throttling / debouncing
  	// functionality and when executed will limit the rate at which `callback`
  	// is executed.
  	function wrapper () {

  		var self = this;
  		var elapsed = Number(new Date()) - lastExec;
  		var args = arguments;

  		// Execute `callback` and update the `lastExec` timestamp.
  		function exec () {
  			lastExec = Number(new Date());
  			callback.apply(self, args);
  		}

  		// If `debounceMode` is true (at begin) this is used to clear the flag
  		// to allow future `callback` executions.
  		function clear () {
  			timeoutID = undefined;
  		}

  		if ( debounceMode && !timeoutID ) {
  			// Since `wrapper` is being called for the first time and
  			// `debounceMode` is true (at begin), execute `callback`.
  			exec();
  		}

  		// Clear any existing timeout.
  		if ( timeoutID ) {
  			clearTimeout(timeoutID);
  		}

  		if ( debounceMode === undefined && elapsed > delay ) {
  			// In throttle mode, if `delay` time has been exceeded, execute
  			// `callback`.
  			exec();

  		} else if ( noTrailing !== true ) {
  			// In trailing throttle mode, since `delay` time has not been
  			// exceeded, schedule `callback` to execute `delay` ms after most
  			// recent execution.
  			//
  			// If `debounceMode` is true (at begin), schedule `clear` to execute
  			// after `delay` ms.
  			//
  			// If `debounceMode` is false (at end), schedule `callback` to
  			// execute after `delay` ms.
  			timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
  		}

  	}

  	// Return the wrapper function.
  	return wrapper;

  };

  var cubic = function (value) { return Math.pow(value, 3); };
  var easeInOutCubic = function (value) { return value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2; };

  var script$a = {
    name: 'ElBacktop',
    components: {
      ElIcon: ElIcon__default
    },
    props: {
      visibilityHeight: {
        type: Number,
        default: 200
      },
      target: {
        type: String,
        default: null
      },
      right: {
        type: Number,
        default: 40
      },
      bottom: {
        type: Number,
        default: 40
      }
    },

    setup: function setup(props, ref$1) {
      var emit = ref$1.emit;

      var el = vue.ref(null);
      var container = vue.ref(null);
      var visible = vue.ref(null);
      var throttledScrollHandler;

      var ref$2 = vue.toRefs(props);
      var visibilityHeight = ref$2.visibilityHeight;
      var target = ref$2.target;
      var right = ref$2.right;
      var bottom = ref$2.bottom;

      var styleBottom = vue.computed(function () { return ((bottom.value) + "px"); });
      var styleRight = vue.computed(function () { return ((right.value) + "px"); });

      var init = function () {
        container.value = document;
        el.value = document.documentElement;
        if (target.value) {
          el.value = document.querySelector(target.value);
          if (!el.value) {
            throw new Error(("target is not existed: " + (target.value)))
          }
          container.value = el.value;
        }
      };

      var onScroll = function () {
        var scrollTop = el.value.scrollTop;
        visible.value = scrollTop >= visibilityHeight.value;
      };

      var handleClick = function (e) {
        scrollToTop();
        emit('click', e);
      };

      var scrollToTop = function () {
        var element = el.value;
        var beginTime = Date.now();
        var beginValue = element.scrollTop;
        var rAF =
          window.requestAnimationFrame || (function (func) { return setTimeout(func, 16); });
        var frameFunc = function () {
          var progress = (Date.now() - beginTime) / 500;
          if (progress < 1) {
            element.scrollTop = beginValue * (1 - easeInOutCubic(progress));
            rAF(frameFunc);
          } else {
            element.scrollTop = 0;
          }
        };
        rAF(frameFunc);
      };

      vue.onMounted(function () {
        init();
        throttledScrollHandler = throttle(300, onScroll);
        container.value.addEventListener('scroll', throttledScrollHandler);
      });

      vue.onUnmounted(function () {
        container.value.removeEventListener('scroll', throttledScrollHandler);
      });

      return {
        visible: visible,
        styleBottom: styleBottom,
        styleRight: styleRight,
        handleClick: handleClick
      }
    }
  };

  function render$a(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_el_icon = vue.resolveComponent("el-icon");

    return (vue.openBlock(), vue.createBlock(vue.Transition, { name: "el-fade-in" }, {
      default: vue.withCtx(function () { return [
        (_ctx.visible)
          ? (vue.openBlock(), vue.createBlock("div", {
              key: 0,
              onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {
                var args = [], len = arguments.length;
                while ( len-- ) args[ len ] = arguments[ len ];

                return (_ctx.handleClick.apply(_ctx, args));
        }, ["stop"])),
              style: {
          right: _ctx.styleRight,
          bottom: _ctx.styleBottom
        },
              class: "el-backtop"
            }, [
              vue.renderSlot(_ctx.$slots, "default", {}, function () { return [
                vue.createVNode(_component_el_icon, { name: "caret-top" })
              ]; })
            ], 4 /* STYLE */))
          : vue.createCommentVNode("v-if", true)
      ]; }),
      _: 1
    }))
  }

  script$a.render = render$a;
  script$a.__file = "packages/backtop/Backtop.vue";

  /* istanbul ignore next */
  script$a.install = function (app) {
    app.component(script$a.name, script$a);
  };

  var version = "0.0.12";

  // 用于构建时的入口

  var components = [
    script,
    script$1,
    script$2,
    script$4,
    script$5,
    script$6,
    script$7,
    script$8,
    script$9,
    script$a
  ];

  var install = function (app) {
    components.forEach(function (component) {
      app.component(component.name, component);
    });
  };

  var elementUI = {
    version: version,
    install: install
  };

  exports.ElAlert = script;
  exports.ElBacktop = script$a;
  exports.ElBreadcrumb = script$8;
  exports.ElBreadcrumbItem = script$9;
  exports.ElButton = script$2;
  exports.ElContainer = script$1;
  exports.ElIcon = script$7;
  exports.ElLink = script$6;
  exports.ElProgress = script$5;
  exports.ElSwitch = script$4;
  exports.default = elementUI;

  return exports;

}({}, Vue, ElIcon));
