var _Select;

import { TransitionGroup, withDirectives, createVNode, mergeProps, createTextVNode } from "vue";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import KeyCode from '../_util/KeyCode';
import PropTypes from '../_util/vue-types';
import classnames from '../_util/classNames';
import classes from 'component-classes';
import { Item as MenuItem, ItemGroup as MenuItemGroup } from '../vc-menu';
import warning from 'warning';
import Option from './Option';
import OptGroup from './OptGroup';
import { hasProp, getPropsData, getValueByProp as getValue, getComponent, getEvents, getOptionProps, getSlot, findDOMNode } from '../_util/props-util';
import getTransitionProps from '../_util/getTransitionProps';
import { cloneElement } from '../_util/vnode';
import BaseMixin from '../_util/BaseMixin';
import SelectTrigger from './SelectTrigger';
import { defaultFilterFn, findFirstMenuItem, findIndexInValueBySingleValue, generateUUID, getLabelFromPropsValue, getMapKey, getPropValue, getValuePropValue, includesSeparators, isCombobox, isMultipleOrTags, isMultipleOrTagsOrCombobox, isSingleMode, preventDefaultEvent, saveRef, splitBySeparators, toArray, toTitle, UNSELECTABLE_ATTRIBUTE, UNSELECTABLE_STYLE, validateOptionValue } from './util';
import { SelectPropTypes } from './PropTypes';
import contains from '../vc-util/Dom/contains';
import { isIE, isEdge } from '../_util/env';
import isValid from '../_util/isValid';
import { getDataAndAriaProps } from '../_util/util';
import antInput from '../_util/antInputDirective';
var SELECT_EMPTY_VALUE_KEY = 'RC_SELECT_EMPTY_VALUE_KEY';

var noop = function noop() {
  return null;
}; // Where el is the DOM element you'd like to test for visibility


function isHidden(node) {
  return !node || node.offsetParent === null;
}

function chaining() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    // eslint-disable-line
    // eslint-disable-line
    for (var i = 0; i < fns.length; i++) {
      if (fns[i] && typeof fns[i] === 'function') {
        fns[i].apply(chaining, args);
      }
    }
  };
}

var Select = (_Select = {
  inheritAttrs: false,
  Option: Option,
  OptGroup: OptGroup,
  name: 'Select',
  mixins: [BaseMixin]
}, _defineProperty(_Select, "inheritAttrs", false), _defineProperty(_Select, "props", _objectSpread(_objectSpread({}, SelectPropTypes), {}, {
  prefixCls: SelectPropTypes.prefixCls.def('rc-select'),
  defaultOpen: PropTypes.bool.def(false),
  labelInValue: SelectPropTypes.labelInValue.def(false),
  defaultActiveFirstOption: SelectPropTypes.defaultActiveFirstOption.def(true),
  showSearch: SelectPropTypes.showSearch.def(true),
  allowClear: SelectPropTypes.allowClear.def(false),
  placeholder: SelectPropTypes.placeholder.def(''),
  // showArrow: SelectPropTypes.showArrow.def(true),
  dropdownMatchSelectWidth: PropTypes.bool.def(true),
  dropdownStyle: SelectPropTypes.dropdownStyle.def(function () {
    return {};
  }),
  dropdownMenuStyle: PropTypes.object.def(function () {
    return {};
  }),
  optionFilterProp: SelectPropTypes.optionFilterProp.def('value'),
  optionLabelProp: SelectPropTypes.optionLabelProp.def('value'),
  notFoundContent: PropTypes.any.def('Not Found'),
  backfill: PropTypes.bool.def(false),
  showAction: SelectPropTypes.showAction.def(['click']),
  combobox: PropTypes.bool.def(false),
  tokenSeparators: PropTypes.arrayOf(PropTypes.string).def([]),
  autoClearSearchValue: PropTypes.bool.def(true),
  tabindex: PropTypes.any.def(0),
  dropdownRender: PropTypes.func.def(function (_ref) {
    var menuNode = _ref.menuNode;
    return menuNode;
  }) // onChange: noop,
  // onFocus: noop,
  // onBlur: noop,
  // onSelect: noop,
  // onSearch: noop,
  // onDeselect: noop,
  // onInputKeydown: noop,

})), _defineProperty(_Select, "created", function created() {
  this.saveInputRef = saveRef(this, 'inputRef');
  this.saveInputMirrorRef = saveRef(this, 'inputMirrorRef');
  this.saveTopCtrlRef = saveRef(this, 'topCtrlRef');
  this.saveSelectTriggerRef = saveRef(this, 'selectTriggerRef');
  this.saveRootRef = saveRef(this, 'rootRef');
  this.saveSelectionRef = saveRef(this, 'selectionRef');
  this._focused = false;
  this._mouseDown = false;
  this._options = [];
  this._empty = false;
}), _defineProperty(_Select, "data", function data() {
  var props = getOptionProps(this);
  var optionsInfo = this.getOptionsInfoFromProps(props);
  warning(this.__propsSymbol__, 'Replace slots.default with props.children and pass props.__propsSymbol__');

  if (props.tags && typeof props.filterOption !== 'function') {
    var isDisabledExist = Object.keys(optionsInfo).some(function (key) {
      return optionsInfo[key].disabled;
    });
    warning(!isDisabledExist, 'Please avoid setting option to disabled in tags mode since user can always type text as tag.');
  }

  var state = {
    _value: this.getValueFromProps(props, true),
    // true: use default value
    _inputValue: props.combobox ? this.getInputValueForCombobox(props, optionsInfo, true // use default value
    ) : '',
    _open: props.defaultOpen,
    _optionsInfo: optionsInfo,
    _backfillValue: '',
    // a flag for aviod redundant getOptionsInfoFromProps call
    _skipBuildOptionsInfo: true,
    _ariaId: generateUUID()
  };
  return _objectSpread(_objectSpread({}, state), this.getDerivedState(props, state));
}), _defineProperty(_Select, "mounted", function mounted() {
  var _this = this;

  this.$nextTick(function () {
    // when defaultOpen is true, we should auto focus search input
    // https://github.com/ant-design/ant-design/issues/14254
    if (_this.autofocus || _this._open) {
      _this.focus();
    } // this.setState({
    //   _ariaId: generateUUID(),
    // });

  });
}), _defineProperty(_Select, "watch", {
  __propsSymbol__: function __propsSymbol__() {
    _extends(this.$data, this.getDerivedState(getOptionProps(this), this.$data));
  }
}), _defineProperty(_Select, "updated", function updated() {
  var _this2 = this;

  this.$nextTick(function () {
    _this2.updateInputWidth();

    _this2.forcePopupAlign();
  });
}), _defineProperty(_Select, "beforeUnmount", function beforeUnmount() {
  this.clearFocusTime();
  this.clearBlurTime();
  this.clearComboboxTime();

  if (this.dropdownContainer) {
    document.body.removeChild(this.dropdownContainer);
    this.dropdownContainer = null;
  }
}), _defineProperty(_Select, "methods", {
  updateInputWidth: function updateInputWidth() {
    if (isMultipleOrTags(this.$props)) {
      var inputNode = this.getInputDOMNode();
      var mirrorNode = this.getInputMirrorDOMNode();

      if (inputNode && inputNode.value && mirrorNode) {
        inputNode.style.width = '';
        inputNode.style.width = "".concat(mirrorNode.clientWidth + 10, "px");
      } else if (inputNode) {
        inputNode.style.width = '';
      }
    }
  },
  getDerivedState: function getDerivedState(nextProps, prevState) {
    var optionsInfo = prevState._skipBuildOptionsInfo ? prevState._optionsInfo : this.getOptionsInfoFromProps(nextProps, prevState);
    var newState = {
      _optionsInfo: optionsInfo,
      _skipBuildOptionsInfo: false
    };

    if ('open' in nextProps) {
      newState._open = nextProps.open;
    }

    if ('value' in nextProps) {
      var value = this.getValueFromProps(nextProps);
      newState._value = value;

      if (nextProps.combobox) {
        newState._inputValue = this.getInputValueForCombobox(nextProps, optionsInfo);
      }
    }

    return newState;
  },
  getOptionsFromChildren: function getOptionsFromChildren() {
    var _this3 = this;

    var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    children.forEach(function (child) {
      var _child$type;

      if (!child) {
        return;
      }

      if ((_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.isSelectOptGroup) {
        _this3.getOptionsFromChildren(getSlot(child), options);
      } else {
        options.push(child);
      }
    });
    return options;
  },
  getInputValueForCombobox: function getInputValueForCombobox(props, optionsInfo, useDefaultValue) {
    var value = [];

    if ('value' in props && !useDefaultValue) {
      value = toArray(props.value);
    }

    if ('defaultValue' in props && useDefaultValue) {
      value = toArray(props.defaultValue);
    }

    if (value.length) {
      value = value[0];
    } else {
      return '';
    }

    var label = value;

    if (props.labelInValue) {
      label = value.label;
    } else if (optionsInfo[getMapKey(value)]) {
      label = optionsInfo[getMapKey(value)].label;
    }

    if (label === undefined) {
      label = '';
    }

    return label;
  },
  getLabelFromOption: function getLabelFromOption(props, option) {
    return getPropValue(option, props.optionLabelProp);
  },
  getOptionsInfoFromProps: function getOptionsInfoFromProps(props, preState) {
    var _this4 = this;

    var options = this.getOptionsFromChildren(this.$props.children);
    var optionsInfo = {};
    options.forEach(function (option) {
      var singleValue = getValuePropValue(option);
      optionsInfo[getMapKey(singleValue)] = {
        option: option,
        value: singleValue,
        label: _this4.getLabelFromOption(props, option),
        title: getValue(option, 'title'),
        disabled: getValue(option, 'disabled')
      };
    });

    if (preState) {
      // keep option info in pre state value.
      var oldOptionsInfo = preState._optionsInfo;
      var value = preState._value;

      if (value) {
        value.forEach(function (v) {
          var key = getMapKey(v);

          if (!optionsInfo[key] && oldOptionsInfo[key] !== undefined) {
            optionsInfo[key] = oldOptionsInfo[key];
          }
        });
      }
    }

    return optionsInfo;
  },
  getValueFromProps: function getValueFromProps(props, useDefaultValue) {
    var value = [];

    if ('value' in props && !useDefaultValue) {
      value = toArray(props.value);
    }

    if ('defaultValue' in props && useDefaultValue) {
      value = toArray(props.defaultValue);
    }

    if (props.labelInValue) {
      value = value.map(function (v) {
        return v.key;
      });
    }

    return value;
  },
  onInputChange: function onInputChange(e) {
    var val = e.target.value;
    var tokenSeparators = this.$props.tokenSeparators;

    if (isMultipleOrTags(this.$props) && tokenSeparators.length && includesSeparators(val, tokenSeparators)) {
      var nextValue = this.getValueByInput(val);

      if (nextValue !== undefined) {
        this.fireChange(nextValue);
      }

      this.setOpenState(false, {
        needFocus: true
      });
      this.setInputValue('', false);
      return;
    }

    this.setInputValue(val);
    this.setState({
      _open: true
    });

    if (isCombobox(this.$props)) {
      this.fireChange([val]);
    }
  },
  onDropdownVisibleChange: function onDropdownVisibleChange(open) {
    if (open && !this._focused) {
      this.clearBlurTime();
      this.timeoutFocus();
      this._focused = true;
      this.updateFocusClassName();
    }

    this.setOpenState(open);
  },
  // combobox ignore
  onKeyDown: function onKeyDown(event) {
    var open = this.$data._open;
    var disabled = this.$props.disabled;

    if (disabled) {
      return;
    }

    var keyCode = event.keyCode;

    if (open && !this.getInputDOMNode()) {
      this.onInputKeydown(event);
    } else if (keyCode === KeyCode.ENTER || keyCode === KeyCode.DOWN) {
      // vue state是同步更新，onKeyDown在onMenuSelect后会再次调用，单选时不在调用setOpenState
      // https://github.com/vueComponent/ant-design-vue/issues/1142
      if (keyCode === KeyCode.ENTER && !isMultipleOrTags(this.$props)) {
        this.maybeFocus(true);
      } else if (!open) {
        this.setOpenState(true);
      }

      event.preventDefault();
    } else if (keyCode === KeyCode.SPACE) {
      // Not block space if popup is shown
      if (!open) {
        this.setOpenState(true);
        event.preventDefault();
      }
    }
  },
  onInputKeydown: function onInputKeydown(event) {
    var _this5 = this;

    var _this$$props = this.$props,
        disabled = _this$$props.disabled,
        combobox = _this$$props.combobox,
        defaultActiveFirstOption = _this$$props.defaultActiveFirstOption;

    if (disabled) {
      return;
    }

    var state = this.$data;
    var isRealOpen = this.getRealOpenState(state);
    var keyCode = event.keyCode;

    if (isMultipleOrTags(this.$props) && !event.target.value && keyCode === KeyCode.BACKSPACE) {
      event.preventDefault();
      var value = state._value;

      if (value.length) {
        this.removeSelected(value[value.length - 1]);
      }

      return;
    }

    if (keyCode === KeyCode.DOWN) {
      if (!state._open) {
        this.openIfHasChildren();
        event.preventDefault();
        event.stopPropagation();
        return;
      }
    } else if (keyCode === KeyCode.ENTER && state._open) {
      // Aviod trigger form submit when select item
      // https://github.com/ant-design/ant-design/issues/10861
      // https://github.com/ant-design/ant-design/issues/14544
      if (isRealOpen || !combobox) {
        event.preventDefault();
      } // Hard close popup to avoid lock of non option in combobox mode


      if (isRealOpen && combobox && defaultActiveFirstOption === false) {
        this.comboboxTimer = setTimeout(function () {
          _this5.setOpenState(false);
        });
      }
    } else if (keyCode === KeyCode.ESC) {
      if (state._open) {
        this.setOpenState(false);
        event.preventDefault();
        event.stopPropagation();
      }

      return;
    }

    if (isRealOpen && this.selectTriggerRef) {
      var menu = this.selectTriggerRef.getInnerMenu();

      if (menu && menu.onKeyDown(event, this.handleBackfill)) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  },
  onMenuSelect: function onMenuSelect(_ref2) {
    var item = _ref2.item;

    if (!item) {
      return;
    }

    var value = this.$data._value;
    var props = this.$props;
    var selectedValue = getValuePropValue(item);
    var lastValue = value[value.length - 1];
    var skipTrigger = false;

    if (isMultipleOrTags(props)) {
      if (findIndexInValueBySingleValue(value, selectedValue) !== -1) {
        skipTrigger = true;
      } else {
        value = value.concat([selectedValue]);
      }
    } else {
      if (!isCombobox(props) && lastValue !== undefined && lastValue === selectedValue && selectedValue !== this.$data._backfillValue) {
        this.setOpenState(false, {
          needFocus: true,
          fireSearch: false
        });
        skipTrigger = true;
      } else {
        value = [selectedValue];
        this.setOpenState(false, {
          needFocus: true,
          fireSearch: false
        });
      }
    }

    if (!skipTrigger) {
      this.fireChange(value);
    }

    if (!skipTrigger) {
      this.fireSelect(selectedValue);
      var inputValue = isCombobox(props) ? getPropValue(item, props.optionLabelProp) : '';

      if (props.autoClearSearchValue) {
        this.setInputValue(inputValue, false);
      }
    }
  },
  onMenuDeselect: function onMenuDeselect(_ref3) {
    var item = _ref3.item,
        domEvent = _ref3.domEvent;

    if (domEvent.type === 'keydown' && domEvent.keyCode === KeyCode.ENTER) {
      var menuItemDomNode = findDOMNode(item); // https://github.com/ant-design/ant-design/issues/20465#issuecomment-569033796

      if (!isHidden(menuItemDomNode)) {
        this.removeSelected(getValuePropValue(item));
      }

      return;
    }

    if (this.autoClearSearchValue) {
      this.setInputValue('');
    }
  },
  onArrowClick: function onArrowClick(e) {
    e.stopPropagation();
    e.preventDefault();
    this.clearBlurTime();

    if (!this.disabled) {
      this.setOpenState(!this.$data._open, {
        needFocus: !this.$data._open
      });
    }
  },
  onPlaceholderClick: function onPlaceholderClick() {
    if (this.getInputDOMNode() && this.getInputDOMNode()) {
      this.getInputDOMNode().focus();
    }
  },
  onPopupFocus: function onPopupFocus() {
    // fix ie scrollbar, focus element again
    this.maybeFocus(true, true);
  },
  onClearSelection: function onClearSelection(event) {
    var props = this.$props;
    var state = this.$data;

    if (props.disabled) {
      return;
    }

    var inputValue = state._inputValue,
        value = state._value;
    event.stopPropagation();

    if (inputValue || value.length) {
      if (value.length) {
        this.fireChange([]);
      }

      this.setOpenState(false, {
        needFocus: true
      });

      if (inputValue) {
        this.setInputValue('');
      }
    }
  },
  onChoiceAnimationLeave: function onChoiceAnimationLeave() {
    this.forcePopupAlign();
  },
  getOptionInfoBySingleValue: function getOptionInfoBySingleValue(value, optionsInfo) {
    var info;
    optionsInfo = optionsInfo || this.$data._optionsInfo;

    if (optionsInfo[getMapKey(value)]) {
      info = optionsInfo[getMapKey(value)];
    }

    if (info) {
      return info;
    }

    var defaultLabel = value;

    if (this.$props.labelInValue) {
      var valueLabel = getLabelFromPropsValue(this.$props.value, value);
      var defaultValueLabel = getLabelFromPropsValue(this.$props.defaultValue, value);

      if (valueLabel !== undefined) {
        defaultLabel = valueLabel;
      } else if (defaultValueLabel !== undefined) {
        defaultLabel = defaultValueLabel;
      }
    }

    var defaultInfo = {
      option: createVNode(Option, {
        "value": value,
        "key": value
      }, {
        default: function _default() {
          return [value];
        }
      }),
      value: value,
      label: defaultLabel
    };
    return defaultInfo;
  },
  getOptionBySingleValue: function getOptionBySingleValue(value) {
    var _this$getOptionInfoBy = this.getOptionInfoBySingleValue(value),
        option = _this$getOptionInfoBy.option;

    return option;
  },
  getOptionsBySingleValue: function getOptionsBySingleValue(values) {
    var _this6 = this;

    return values.map(function (value) {
      return _this6.getOptionBySingleValue(value);
    });
  },
  getValueByLabel: function getValueByLabel(label) {
    var _this7 = this;

    if (label === undefined) {
      return null;
    }

    var value = null;
    Object.keys(this.$data._optionsInfo).forEach(function (key) {
      var info = _this7.$data._optionsInfo[key];
      var disabled = info.disabled;

      if (disabled) {
        return;
      }

      var oldLable = toArray(info.label);

      if (oldLable && oldLable.join('') === label) {
        value = info.value;
      }
    });
    return value;
  },
  getVLBySingleValue: function getVLBySingleValue(value) {
    if (this.$props.labelInValue) {
      return {
        key: value,
        label: this.getLabelBySingleValue(value)
      };
    }

    return value;
  },
  getVLForOnChange: function getVLForOnChange(vlsS) {
    var _this8 = this;

    var vls = vlsS;

    if (vls !== undefined) {
      if (!this.labelInValue) {
        vls = vls.map(function (v) {
          return v;
        });
      } else {
        vls = vls.map(function (vl) {
          return {
            key: vl,
            label: _this8.getLabelBySingleValue(vl)
          };
        });
      }

      return isMultipleOrTags(this.$props) ? vls : vls[0];
    }

    return vls;
  },
  getLabelBySingleValue: function getLabelBySingleValue(value, optionsInfo) {
    var _this$getOptionInfoBy2 = this.getOptionInfoBySingleValue(value, optionsInfo),
        label = _this$getOptionInfoBy2.label;

    return label;
  },
  getDropdownContainer: function getDropdownContainer() {
    if (!this.dropdownContainer) {
      this.dropdownContainer = document.createElement('div');
      document.body.appendChild(this.dropdownContainer);
    }

    return this.dropdownContainer;
  },
  getPlaceholderElement: function getPlaceholderElement() {
    var props = this.$props,
        state = this.$data;
    var hidden = false;

    if (state._inputValue) {
      hidden = true;
    }

    var value = state._value;

    if (value.length) {
      hidden = true;
    }

    if (isCombobox(props) && value.length === 1 && state._value && !isValid(state._value[0])) {
      hidden = false;
    }

    var placeholder = props.placeholder;

    if (placeholder) {
      var p = _objectSpread(_objectSpread({
        onMousedown: preventDefaultEvent,
        onClick: this.onPlaceholderClick
      }, UNSELECTABLE_ATTRIBUTE), {}, {
        style: _objectSpread({
          display: hidden ? 'none' : 'block'
        }, UNSELECTABLE_STYLE),
        class: "".concat(props.prefixCls, "-selection__placeholder")
      });

      return createVNode("div", p, [placeholder]);
    }

    return null;
  },
  inputClick: function inputClick(e) {
    if (this.$data._open) {
      this.clearBlurTime();
      e.stopPropagation();
    } else {
      this._focused = false;
    }
  },
  inputBlur: function inputBlur(e) {
    var _this9 = this;

    var target = e.relatedTarget || document.activeElement; // https://github.com/vueComponent/ant-design-vue/issues/999
    // https://github.com/vueComponent/ant-design-vue/issues/1223

    if ((isIE || isEdge) && (e.relatedTarget === this.$refs.arrow || target && this.selectTriggerRef && findDOMNode(this.selectTriggerRef.getInnerMenu()) === target || contains(e.target, target))) {
      e.target.focus();
      e.preventDefault();
      return;
    }

    if (this.disabled) {
      e.preventDefault();
      return;
    }

    this.blurTimer = setTimeout(function () {
      _this9._focused = false;

      _this9.updateFocusClassName();

      var props = _this9.$props;
      var value = _this9.$data._value;
      var inputValue = _this9.$data._inputValue;

      if (isSingleMode(props) && props.showSearch && inputValue && props.defaultActiveFirstOption) {
        var options = _this9._options || [];

        if (options.length) {
          var firstOption = findFirstMenuItem(options);

          if (firstOption) {
            value = [getValuePropValue(firstOption)];

            _this9.fireChange(value);
          }
        }
      } else if (isMultipleOrTags(props) && inputValue) {
        if (_this9._mouseDown) {
          // need update dropmenu when not blur
          _this9.setInputValue('');
        } else {
          // why not use setState?
          _this9.$data._inputValue = '';

          if (_this9.getInputDOMNode && _this9.getInputDOMNode()) {
            _this9.getInputDOMNode().value = '';
          }
        }

        var tmpValue = _this9.getValueByInput(inputValue);

        if (tmpValue !== undefined) {
          value = tmpValue;

          _this9.fireChange(value);
        }
      } // if click the rest space of Select in multiple mode


      if (isMultipleOrTags(props) && _this9._mouseDown) {
        _this9.maybeFocus(true, true);

        _this9._mouseDown = false;
        return;
      }

      _this9.setOpenState(false);

      _this9.__emit('blur', _this9.getVLForOnChange(value));
    }, 200);
  },
  inputFocus: function inputFocus(e) {
    if (this.$props.disabled) {
      e.preventDefault();
      return;
    }

    this.clearBlurTime(); // In IE11, onOuterFocus will be trigger twice when focus input
    // First one: e.target is div
    // Second one: e.target is input
    // other browser only trigger second one
    // https://github.com/ant-design/ant-design/issues/15942
    // Here we ignore the first one when e.target is div

    var inputNode = this.getInputDOMNode();

    if (inputNode && e.target === this.rootRef) {
      return;
    }

    if (!isMultipleOrTagsOrCombobox(this.$props) && e.target === inputNode) {
      return;
    }

    if (this._focused) {
      return;
    }

    this._focused = true;
    this.updateFocusClassName(); // only effect multiple or tag mode

    if (!isMultipleOrTags(this.$props) || !this._mouseDown) {
      this.timeoutFocus();
    }
  },
  _getInputElement: function _getInputElement() {
    var props = this.$props;
    var inputValue = this.$data._inputValue;
    var attrs = this.$attrs;
    var defaultInput = createVNode("input", mergeProps(attrs.id !== undefined ? {
      id: attrs.id
    } : {}, {
      "autocomplete": "off"
    }), null);
    var inputElement = props.getInputElement ? props.getInputElement() : defaultInput;
    var inputCls = classnames(inputElement.props && inputElement.props.class, _defineProperty({}, "".concat(props.prefixCls, "-search__field"), true));
    var inputEvents = getEvents(inputElement); // https://github.com/ant-design/ant-design/issues/4992#issuecomment-281542159
    // Add space to the end of the inputValue as the width measurement tolerance

    return createVNode("div", {
      "class": "".concat(props.prefixCls, "-search__field__wrap"),
      "onClick": this.inputClick
    }, [cloneElement(withDirectives(inputElement, [[antInput]]), _objectSpread(_objectSpread({
      disabled: props.disabled
    }, inputElement.props || {}), {}, {
      disabled: props.disabled,
      value: inputValue,
      class: inputCls,
      ref: this.saveInputRef,
      onInput: this.onInputChange,
      onKeydown: chaining(this.onInputKeydown, inputEvents.onKeydown, this.$attrs.onInputKeydown),
      onFocus: chaining(this.inputFocus, inputEvents.onFocus),
      onBlur: chaining(this.inputBlur, inputEvents.onBlur)
    })), createVNode("span", {
      "ref": this.saveInputMirrorRef,
      "class": "".concat(props.prefixCls, "-search__field__mirror")
    }, [inputValue, createTextVNode("\xA0")])]);
  },
  getInputDOMNode: function getInputDOMNode() {
    return this.topCtrlRef ? this.topCtrlRef.querySelector('input,textarea,div[contentEditable]') : this.inputRef;
  },
  getInputMirrorDOMNode: function getInputMirrorDOMNode() {
    return this.inputMirrorRef;
  },
  getPopupDOMNode: function getPopupDOMNode() {
    if (this.selectTriggerRef) {
      return this.selectTriggerRef.getPopupDOMNode();
    }
  },
  getPopupMenuComponent: function getPopupMenuComponent() {
    if (this.selectTriggerRef) {
      return this.selectTriggerRef.getInnerMenu();
    }
  },
  setOpenState: function setOpenState(open) {
    var _this10 = this;

    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var props = this.$props,
        state = this.$data;
    var needFocus = config.needFocus,
        fireSearch = config.fireSearch;

    if (state._open === open) {
      this.maybeFocus(open, !!needFocus);
      return;
    }

    this.__emit('dropdownVisibleChange', open);

    var nextState = {
      _open: open,
      _backfillValue: ''
    }; // clear search input value when open is false in singleMode.

    if (!open && isSingleMode(props) && props.showSearch) {
      this.setInputValue('', fireSearch);
    }

    if (!open) {
      this.maybeFocus(open, !!needFocus);
    }

    this.setState(nextState, function () {
      if (open) {
        _this10.maybeFocus(open, !!needFocus);
      }
    });
  },
  setInputValue: function setInputValue(inputValue) {
    var fireSearch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (inputValue !== this.$data._inputValue) {
      this.setState({
        _inputValue: inputValue
      }, this.forcePopupAlign);

      if (fireSearch) {
        this.__emit('search', inputValue);
      }
    }
  },
  getValueByInput: function getValueByInput(str) {
    var _this11 = this;

    var _this$$props2 = this.$props,
        multiple = _this$$props2.multiple,
        tokenSeparators = _this$$props2.tokenSeparators;
    var nextValue = this.$data._value;
    var hasNewValue = false;
    splitBySeparators(str, tokenSeparators).forEach(function (label) {
      var selectedValue = [label];

      if (multiple) {
        var value = _this11.getValueByLabel(label);

        if (value && findIndexInValueBySingleValue(nextValue, value) === -1) {
          nextValue = nextValue.concat(value);
          hasNewValue = true;

          _this11.fireSelect(value);
        }
      } else if (findIndexInValueBySingleValue(nextValue, label) === -1) {
        nextValue = nextValue.concat(selectedValue);
        hasNewValue = true;

        _this11.fireSelect(label);
      }
    });
    return hasNewValue ? nextValue : undefined;
  },
  getRealOpenState: function getRealOpenState(state) {
    var _open = this.$props.open;

    if (typeof _open === 'boolean') {
      return _open;
    }

    var open = (state || this.$data)._open;
    var options = this._options || [];

    if (isMultipleOrTagsOrCombobox(this.$props) || !this.$props.showSearch) {
      if (open && !options.length) {
        open = false;
      }
    }

    return open;
  },
  focus: function focus() {
    if (isSingleMode(this.$props) && this.selectionRef) {
      this.selectionRef.focus();
    } else if (this.getInputDOMNode()) {
      this.getInputDOMNode().focus();
    }
  },
  blur: function blur() {
    if (isSingleMode(this.$props) && this.selectionRef) {
      this.selectionRef.blur();
    } else if (this.getInputDOMNode()) {
      this.getInputDOMNode().blur();
    }
  },
  markMouseDown: function markMouseDown() {
    this._mouseDown = true;
  },
  markMouseLeave: function markMouseLeave() {
    this._mouseDown = false;
  },
  handleBackfill: function handleBackfill(item) {
    if (!this.backfill || !(isSingleMode(this.$props) || isCombobox(this.$props))) {
      return;
    }

    var key = getValuePropValue(item);

    if (isCombobox(this.$props)) {
      this.setInputValue(key, false);
    }

    this.setState({
      _value: [key],
      _backfillValue: key
    });
  },
  _filterOption: function _filterOption(input, child) {
    var defaultFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultFilterFn;
    var _this$$data = this.$data,
        value = _this$$data._value,
        backfillValue = _this$$data._backfillValue;
    var lastValue = value[value.length - 1];

    if (!input || lastValue && lastValue === backfillValue) {
      return true;
    }

    var filterFn = this.$props.filterOption;

    if (hasProp(this, 'filterOption')) {
      if (filterFn === true) {
        filterFn = defaultFilter.bind(this);
      }
    } else {
      filterFn = defaultFilter.bind(this);
    }

    if (!filterFn) {
      return true;
    } else if (typeof filterFn === 'function') {
      return filterFn.call(this, input, child);
    } else if (getValue(child, 'disabled')) {
      return false;
    }

    return true;
  },
  timeoutFocus: function timeoutFocus() {
    var _this12 = this;

    if (this.focusTimer) {
      this.clearFocusTime();
    }

    this.focusTimer = window.setTimeout(function () {
      // this._focused = true
      // this.updateFocusClassName()
      _this12.__emit('focus');
    }, 10);
  },
  clearFocusTime: function clearFocusTime() {
    if (this.focusTimer) {
      clearTimeout(this.focusTimer);
      this.focusTimer = null;
    }
  },
  clearBlurTime: function clearBlurTime() {
    if (this.blurTimer) {
      clearTimeout(this.blurTimer);
      this.blurTimer = null;
    }
  },
  clearComboboxTime: function clearComboboxTime() {
    if (this.comboboxTimer) {
      clearTimeout(this.comboboxTimer);
      this.comboboxTimer = null;
    }
  },
  updateFocusClassName: function updateFocusClassName() {
    var rootRef = this.rootRef,
        prefixCls = this.prefixCls; // avoid setState and its side effect

    if (this._focused) {
      classes(rootRef).add("".concat(prefixCls, "-focused"));
    } else {
      classes(rootRef).remove("".concat(prefixCls, "-focused"));
    }
  },
  maybeFocus: function maybeFocus(open, needFocus) {
    if (needFocus || open) {
      var input = this.getInputDOMNode();
      var _document = document,
          activeElement = _document.activeElement;

      if (input && (open || isMultipleOrTagsOrCombobox(this.$props))) {
        if (activeElement !== input) {
          input.focus();
          this._focused = true;
        }
      } else if (activeElement !== this.selectionRef && this.selectionRef) {
        this.selectionRef.focus();
        this._focused = true;
      }
    }
  },
  removeSelected: function removeSelected(selectedKey, e) {
    var props = this.$props;

    if (props.disabled || this.isChildDisabled(selectedKey)) {
      return;
    } // Do not trigger Trigger popup


    if (e && e.stopPropagation) {
      e.stopPropagation();
    }

    var oldValue = this.$data._value;
    var value = oldValue.filter(function (singleValue) {
      return singleValue !== selectedKey;
    });
    var canMultiple = isMultipleOrTags(props);

    if (canMultiple) {
      var event = selectedKey;

      if (props.labelInValue) {
        event = {
          key: selectedKey,
          label: this.getLabelBySingleValue(selectedKey)
        };
      }

      this.__emit('deselect', event, this.getOptionBySingleValue(selectedKey));
    }

    this.fireChange(value);
  },
  openIfHasChildren: function openIfHasChildren() {
    var $props = this.$props;

    if ($props.children && $props.children.length || isSingleMode($props)) {
      this.setOpenState(true);
    }
  },
  fireSelect: function fireSelect(value) {
    this.__emit('select', this.getVLBySingleValue(value), this.getOptionBySingleValue(value));
  },
  fireChange: function fireChange(value) {
    if (!hasProp(this, 'value')) {
      this.setState({
        _value: value
      }, this.forcePopupAlign);
    }

    var vls = this.getVLForOnChange(value);
    var options = this.getOptionsBySingleValue(value);
    this._valueOptions = options;

    this.__emit('update:value', vls);

    this.__emit('change', vls, isMultipleOrTags(this.$props) ? options : options[0]);
  },
  isChildDisabled: function isChildDisabled(key) {
    return (this.$props.children || []).some(function (child) {
      var childValue = getValuePropValue(child);
      return childValue === key && getValue(child, 'disabled');
    });
  },
  forcePopupAlign: function forcePopupAlign() {
    if (!this.$data._open) {
      return;
    }

    if (this.selectTriggerRef && this.selectTriggerRef.triggerRef) {
      this.selectTriggerRef.triggerRef.forcePopupAlign();
    }
  },
  renderFilterOptions: function renderFilterOptions() {
    var inputValue = this.$data._inputValue;
    var _this$$props3 = this.$props,
        children = _this$$props3.children,
        tags = _this$$props3.tags,
        notFoundContent = _this$$props3.notFoundContent;
    var menuItems = [];
    var childrenKeys = [];
    var empty = false;
    var options = this.renderFilterOptionsFromChildren(children, childrenKeys, menuItems);

    if (tags) {
      // tags value must be string
      var value = this.$data._value;
      value = value.filter(function (singleValue) {
        return childrenKeys.indexOf(singleValue) === -1 && (!inputValue || String(singleValue).indexOf(String(inputValue)) > -1);
      }); // sort by length

      value.sort(function (val1, val2) {
        return val1.length - val2.length;
      });
      value.forEach(function (singleValue) {
        var key = singleValue;

        var attrs = _objectSpread(_objectSpread({}, UNSELECTABLE_ATTRIBUTE), {}, {
          role: 'option'
        });

        var menuItem = createVNode(MenuItem, mergeProps({
          "style": UNSELECTABLE_STYLE
        }, attrs, {
          "value": key,
          "key": key
        }), {
          default: function _default() {
            return [key];
          }
        });
        options.push(menuItem);
        menuItems.push(menuItem);
      }); // ref: https://github.com/ant-design/ant-design/issues/14090

      if (inputValue && menuItems.every(function (option) {
        return getValuePropValue(option) !== inputValue;
      })) {
        var p = _objectSpread(_objectSpread({}, UNSELECTABLE_ATTRIBUTE), {}, {
          key: inputValue,
          value: inputValue,
          role: 'option',
          style: UNSELECTABLE_STYLE
        });

        options.unshift(createVNode(MenuItem, p, {
          default: function _default() {
            return [inputValue];
          }
        }));
      }
    }

    if (!options.length && notFoundContent) {
      empty = true;

      var _p = _objectSpread(_objectSpread({}, UNSELECTABLE_ATTRIBUTE), {}, {
        key: 'NOT_FOUND',
        value: 'NOT_FOUND',
        disabled: true,
        role: 'option',
        style: UNSELECTABLE_STYLE
      });

      options = [createVNode(MenuItem, _p, {
        default: function _default() {
          return [notFoundContent];
        }
      })];
    }

    return {
      empty: empty,
      options: options
    };
  },
  renderFilterOptionsFromChildren: function renderFilterOptionsFromChildren() {
    var _this13 = this;

    var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var childrenKeys = arguments.length > 1 ? arguments[1] : undefined;
    var menuItems = arguments.length > 2 ? arguments[2] : undefined;
    var sel = [];
    var props = this.$props;
    var inputValue = this.$data._inputValue;
    var tags = props.tags;
    children.forEach(function (child) {
      if (!child) {
        return;
      }

      var type = child.type;

      if (type === null || type === void 0 ? void 0 : type.isSelectOptGroup) {
        var label = getComponent(child, 'label');
        var key = child.key;

        if (!key && typeof label === 'string') {
          key = label;
        } else if (!label && key) {
          label = key;
        }

        var childChildren = getComponent(child);
        childChildren = Array.isArray(childChildren) ? childChildren : [childChildren]; // Match option group label

        if (inputValue && _this13._filterOption(inputValue, child)) {
          var innerItems = childChildren.map(function (subChild) {
            var childValueSub = getValuePropValue(subChild) || subChild.key;
            return createVNode(MenuItem, mergeProps({
              "key": childValueSub,
              "value": childValueSub
            }, subChild.props), {
              default: function _default() {
                return _toConsumableArray(getSlot(subChild));
              }
            });
          });
          sel.push(createVNode(MenuItemGroup, {
            "key": key,
            "title": label,
            "class": child.props && child.props.class
          }, {
            default: function _default() {
              return _toConsumableArray(innerItems);
            }
          })); // Not match
        } else {
          var _innerItems = _this13.renderFilterOptionsFromChildren(childChildren, childrenKeys, menuItems);

          if (_innerItems.length) {
            sel.push(createVNode(MenuItemGroup, mergeProps({
              "key": key,
              "title": label
            }, child.props), {
              default: function _default() {
                return _toConsumableArray(_innerItems);
              }
            }));
          }
        }

        return;
      }

      warning(_typeof(type) === 'object' && type.isSelectOption, 'the children of `Select` should be `Select.Option` or `Select.OptGroup`, ');
      var childValue = getValuePropValue(child);
      validateOptionValue(childValue, _this13.$props);

      if (_this13._filterOption(inputValue, child)) {
        var p = _objectSpread(_objectSpread(_objectSpread({}, UNSELECTABLE_ATTRIBUTE), {}, {
          key: childValue,
          value: childValue
        }, getPropsData(child)), {}, {
          role: 'option',
          style: UNSELECTABLE_STYLE,
          class: child === null || child === void 0 ? void 0 : child.class
        });

        var menuItem = createVNode(MenuItem, p, {
          default: function _default() {
            return [getSlot(child)];
          }
        });
        sel.push(menuItem);
        menuItems.push(menuItem);
      }

      if (tags) {
        childrenKeys.push(childValue);
      }
    });
    return sel;
  },
  renderTopControlNode: function renderTopControlNode() {
    var _this14 = this;

    var props = this.$props;
    var _this$$data2 = this.$data,
        value = _this$$data2._value,
        inputValue = _this$$data2._inputValue,
        open = _this$$data2._open;
    var choiceTransitionName = props.choiceTransitionName,
        prefixCls = props.prefixCls,
        maxTagTextLength = props.maxTagTextLength,
        maxTagCount = props.maxTagCount,
        maxTagPlaceholder = props.maxTagPlaceholder,
        showSearch = props.showSearch;
    var removeIcon = getComponent(this, 'removeIcon');
    var className = "".concat(prefixCls, "-selection__rendered"); // search input is inside topControlNode in single, multiple & combobox. 2016/04/13

    var innerNode = null;

    if (isSingleMode(props)) {
      var selectedValue = null;

      if (value.length) {
        var showSelectedValue = false;
        var opacity = 1;

        if (!showSearch) {
          showSelectedValue = true;
        } else if (open) {
          showSelectedValue = !inputValue;

          if (showSelectedValue) {
            opacity = 0.4;
          }
        } else {
          showSelectedValue = true;
        }

        var singleValue = value[0];

        var _this$getOptionInfoBy3 = this.getOptionInfoBySingleValue(singleValue),
            label = _this$getOptionInfoBy3.label,
            title = _this$getOptionInfoBy3.title;

        selectedValue = createVNode("div", {
          "key": "value",
          "class": "".concat(prefixCls, "-selection-selected-value"),
          "title": toTitle(title || label),
          "style": {
            display: showSelectedValue ? 'block' : 'none',
            opacity: opacity
          }
        }, [label]);
      }

      if (!showSearch) {
        innerNode = [selectedValue];
      } else {
        innerNode = [selectedValue, createVNode("div", {
          "class": "".concat(prefixCls, "-search ").concat(prefixCls, "-search--inline"),
          "key": "input",
          "style": {
            display: open ? 'block' : 'none'
          }
        }, [this._getInputElement()])];
      }
    } else {
      var selectedValueNodes = [];
      var limitedCountValue = value;
      var maxTagPlaceholderEl;

      if (maxTagCount !== undefined && value.length > maxTagCount) {
        limitedCountValue = limitedCountValue.slice(0, maxTagCount);
        var omittedValues = this.getVLForOnChange(value.slice(maxTagCount, value.length));
        var content = "+ ".concat(value.length - maxTagCount, " ...");

        if (maxTagPlaceholder) {
          content = typeof maxTagPlaceholder === 'function' ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
        }

        var attrs = _objectSpread(_objectSpread({}, UNSELECTABLE_ATTRIBUTE), {}, {
          role: 'presentation',
          title: toTitle(content)
        });

        maxTagPlaceholderEl = createVNode("li", mergeProps({
          "style": UNSELECTABLE_STYLE
        }, attrs, {
          "onMousedown": preventDefaultEvent,
          "class": "".concat(prefixCls, "-selection__choice ").concat(prefixCls, "-selection__choice__disabled"),
          "key": "maxTagPlaceholder"
        }), [createVNode("div", {
          "class": "".concat(prefixCls, "-selection__choice__content")
        }, [content])]);
      }

      if (isMultipleOrTags(props)) {
        selectedValueNodes = limitedCountValue.map(function (singleValue) {
          var info = _this14.getOptionInfoBySingleValue(singleValue);

          var content = info.label;
          var title = info.title || content;

          if (maxTagTextLength && typeof content === 'string' && content.length > maxTagTextLength) {
            content = "".concat(content.slice(0, maxTagTextLength), "...");
          }

          var disabled = _this14.isChildDisabled(singleValue);

          var choiceClassName = disabled ? "".concat(prefixCls, "-selection__choice ").concat(prefixCls, "-selection__choice__disabled") : "".concat(prefixCls, "-selection__choice"); // attrs 放在一起，避免动态title混乱问题，很奇怪的问题 https://github.com/vueComponent/ant-design-vue/issues/588

          var attrs = _objectSpread(_objectSpread({}, UNSELECTABLE_ATTRIBUTE), {}, {
            role: 'presentation',
            title: toTitle(title)
          });

          return createVNode("li", mergeProps({
            "style": UNSELECTABLE_STYLE
          }, attrs, {
            "onMousedown": preventDefaultEvent,
            "class": choiceClassName,
            "key": singleValue || SELECT_EMPTY_VALUE_KEY
          }), [createVNode("div", {
            "class": "".concat(prefixCls, "-selection__choice__content")
          }, [content]), disabled ? null : createVNode("span", {
            "onClick": function onClick(event) {
              _this14.removeSelected(singleValue, event);
            },
            "class": "".concat(prefixCls, "-selection__choice__remove")
          }, [removeIcon || createVNode("i", {
            "class": "".concat(prefixCls, "-selection__choice__remove-icon")
          }, [createTextVNode("\xD7")])])]);
        });
      }

      if (maxTagPlaceholderEl) {
        selectedValueNodes.push(maxTagPlaceholderEl);
      }

      selectedValueNodes.push(createVNode("li", {
        "class": "".concat(prefixCls, "-search ").concat(prefixCls, "-search--inline"),
        "key": "__input"
      }, [this._getInputElement()]));

      if (isMultipleOrTags(props) && choiceTransitionName) {
        var transitionProps = getTransitionProps(choiceTransitionName, {
          tag: 'ul',
          onAfterLeave: this.onChoiceAnimationLeave
        });
        innerNode = createVNode(TransitionGroup, transitionProps, {
          default: function _default() {
            return [selectedValueNodes];
          }
        });
      } else {
        innerNode = createVNode("ul", null, [selectedValueNodes]);
      }
    }

    return createVNode("div", {
      "class": className,
      "ref": this.saveTopCtrlRef,
      "onClick": this.topCtrlContainerClick
    }, [this.getPlaceholderElement(), innerNode]);
  },
  renderArrow: function renderArrow(multiple) {
    // showArrow : Set to true if not multiple by default but keep set value.
    var _this$$props4 = this.$props,
        _this$$props4$showArr = _this$$props4.showArrow,
        showArrow = _this$$props4$showArr === void 0 ? !multiple : _this$$props4$showArr,
        loading = _this$$props4.loading,
        prefixCls = _this$$props4.prefixCls;
    var inputIcon = getComponent(this, 'inputIcon');

    if (!showArrow && !loading) {
      return null;
    } // if loading  have loading icon


    var defaultIcon = loading ? createVNode("i", {
      "class": "".concat(prefixCls, "-arrow-loading")
    }, null) : createVNode("i", {
      "class": "".concat(prefixCls, "-arrow-icon")
    }, null);
    return createVNode("span", mergeProps({
      "key": "arrow",
      "class": "".concat(prefixCls, "-arrow"),
      "style": UNSELECTABLE_STYLE
    }, UNSELECTABLE_ATTRIBUTE, {
      "onClick": this.onArrowClick,
      "ref": "arrow"
    }), [inputIcon || defaultIcon]);
  },
  topCtrlContainerClick: function topCtrlContainerClick(e) {
    if (this.$data._open && !isSingleMode(this.$props)) {
      e.stopPropagation();
    }
  },
  renderClear: function renderClear() {
    var _this$$props5 = this.$props,
        prefixCls = _this$$props5.prefixCls,
        allowClear = _this$$props5.allowClear;
    var _this$$data3 = this.$data,
        value = _this$$data3._value,
        inputValue = _this$$data3._inputValue;
    var clearIcon = getComponent(this, 'clearIcon');
    var clear = createVNode("span", mergeProps({
      "key": "clear",
      "class": "".concat(prefixCls, "-selection__clear"),
      "onMousedown": preventDefaultEvent,
      "style": UNSELECTABLE_STYLE
    }, UNSELECTABLE_ATTRIBUTE, {
      "onClick": this.onClearSelection
    }), [clearIcon || createVNode("i", {
      "class": "".concat(prefixCls, "-selection__clear-icon")
    }, [createTextVNode("\xD7")])]);

    if (!allowClear) {
      return null;
    }

    if (isCombobox(this.$props)) {
      if (inputValue) {
        return clear;
      }

      return null;
    }

    if (inputValue || value.length) {
      return clear;
    }

    return null;
  },
  selectionRefClick: function selectionRefClick() {
    //e.stopPropagation();
    if (!this.disabled) {
      var input = this.getInputDOMNode();

      if (this._focused && this.$data._open) {
        // this._focused = false;
        this.setOpenState(false, false);
        input && input.blur();
      } else {
        this.clearBlurTime(); //this._focused = true;

        this.setOpenState(true, true);
        input && input.focus();
      }
    }
  },
  selectionRefFocus: function selectionRefFocus(e) {
    this.inputFocus(e);
  },
  selectionRefBlur: function selectionRefBlur(e) {
    if (isMultipleOrTagsOrCombobox(this.$props)) {
      e.preventDefault();
      return;
    }

    this.inputBlur(e);
  }
}), _defineProperty(_Select, "render", function render() {
  var _rootCls,
      _this15 = this;

  var props = this.$props;
  var _this$$attrs = this.$attrs,
      className = _this$$attrs.class,
      style = _this$$attrs.style;
  var multiple = isMultipleOrTags(props); // Default set showArrow to true if not set (not set directly in defaultProps to handle multiple case)

  var _props$showArrow = props.showArrow,
      showArrow = _props$showArrow === void 0 ? true : _props$showArrow;
  var state = this.$data;
  var disabled = props.disabled,
      prefixCls = props.prefixCls,
      loading = props.loading;
  var _this$$data4 = this.$data,
      open = _this$$data4._open,
      inputValue = _this$$data4._inputValue,
      value = _this$$data4._value;

  if (open) {
    var filterOptions = this.renderFilterOptions();
    this._empty = filterOptions.empty;
    this._options = filterOptions.options;
  }

  var realOpen = this.getRealOpenState();
  var empty = this._empty;
  var options = this._options || [];
  var selectionProps = {
    role: 'combobox',
    'aria-autocomplete': 'list',
    'aria-haspopup': 'true',
    'aria-expanded': realOpen,
    'aria-controls': this.$data._ariaId,
    class: "".concat(prefixCls, "-selection ").concat(prefixCls, "-selection--").concat(multiple ? 'multiple' : 'single'),
    key: 'selection'
  }; //if (!isMultipleOrTagsOrCombobox(props)) {
  // selectionProps.on.keydown = this.onKeyDown;
  // selectionProps.on.focus = this.selectionRefFocus;
  // selectionProps.on.blur = this.selectionRefBlur;
  // selectionProps.attrs.tabindex = props.disabled ? -1 : props.tabindex;
  //}

  var rootCls = (_rootCls = {}, _defineProperty(_rootCls, className, className), _defineProperty(_rootCls, prefixCls, true), _defineProperty(_rootCls, "".concat(prefixCls, "-open"), open), _defineProperty(_rootCls, "".concat(prefixCls, "-focused"), open || !!this._focused), _defineProperty(_rootCls, "".concat(prefixCls, "-combobox"), isCombobox(props)), _defineProperty(_rootCls, "".concat(prefixCls, "-disabled"), disabled), _defineProperty(_rootCls, "".concat(prefixCls, "-enabled"), !disabled), _defineProperty(_rootCls, "".concat(prefixCls, "-allow-clear"), !!props.allowClear), _defineProperty(_rootCls, "".concat(prefixCls, "-no-arrow"), !showArrow), _defineProperty(_rootCls, "".concat(prefixCls, "-loading"), !!loading), _rootCls);
  return createVNode(SelectTrigger, {
    "dropdownAlign": props.dropdownAlign,
    "dropdownClassName": props.dropdownClassName,
    "dropdownMatchSelectWidth": props.dropdownMatchSelectWidth,
    "defaultActiveFirstOption": props.defaultActiveFirstOption,
    "dropdownMenuStyle": props.dropdownMenuStyle,
    "transitionName": props.transitionName,
    "animation": props.animation,
    "prefixCls": props.prefixCls,
    "dropdownStyle": props.dropdownStyle,
    "combobox": props.combobox,
    "showSearch": props.showSearch,
    "options": options,
    "empty": empty,
    "multiple": multiple,
    "disabled": disabled,
    "visible": realOpen,
    "inputValue": inputValue,
    "value": value,
    "backfillValue": state._backfillValue,
    "firstActiveValue": props.firstActiveValue,
    "onDropdownVisibleChange": this.onDropdownVisibleChange,
    "getPopupContainer": props.getPopupContainer,
    "onMenuSelect": this.onMenuSelect,
    "onMenuDeselect": this.onMenuDeselect,
    "onPopupScroll": this.$attrs.onPopupScroll,
    "onPopupFocus": this.onPopupFocus,
    "onMouseenter": this.$attrs.onMouseenter,
    "onMouseleave": this.$attrs.onMouseleave,
    "showAction": props.showAction,
    "menuItemSelectedIcon": getComponent(this, 'menuItemSelectedIcon'),
    "ref": this.saveSelectTriggerRef,
    "dropdownRender": props.dropdownRender,
    "ariaId": this.$data._ariaId
  }, {
    default: function _default() {
      return [createVNode("div", mergeProps(getDataAndAriaProps(_this15.$attrs), {
        "ref": chaining(_this15.saveRootRef, _this15.saveSelectionRef),
        "style": style,
        "class": classnames(rootCls),
        "onMousedown": _this15.markMouseDown,
        "onMouseup": _this15.markMouseLeave,
        "onMouseout": _this15.markMouseLeave,
        "tabindex": props.disabled ? -1 : props.tabindex,
        "onBlur": _this15.selectionRefBlur,
        "onFocus": _this15.selectionRefFocus,
        "onClick": _this15.selectionRefClick,
        "onKeydown": isMultipleOrTagsOrCombobox(props) ? noop : _this15.onKeyDown
      }), [createVNode("div", selectionProps, [_this15.renderTopControlNode(), _this15.renderClear(), _this15.renderArrow(!!multiple)])])];
    }
  });
}), _Select);
export { Select };
export default Select;