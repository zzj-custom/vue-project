import { inject, createVNode } from "vue";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import PropTypes from '../_util/vue-types';
import { ConfigConsumerProps } from '../config-provider';
import { getSlot } from '../_util/props-util';
var stringOrNumber = PropTypes.oneOfType([PropTypes.string, PropTypes.number]);
export var ColSize = PropTypes.shape({
  span: stringOrNumber,
  order: stringOrNumber,
  offset: stringOrNumber,
  push: stringOrNumber,
  pull: stringOrNumber
}).loose;
var objectOrNumber = PropTypes.oneOfType([PropTypes.string, PropTypes.number, ColSize]);
export var ColProps = {
  span: stringOrNumber,
  order: stringOrNumber,
  offset: stringOrNumber,
  push: stringOrNumber,
  pull: stringOrNumber,
  xs: objectOrNumber,
  sm: objectOrNumber,
  md: objectOrNumber,
  lg: objectOrNumber,
  xl: objectOrNumber,
  xxl: objectOrNumber,
  prefixCls: PropTypes.string,
  flex: stringOrNumber
};
export default {
  name: 'ACol',
  props: ColProps,
  setup: function setup() {
    return {
      configProvider: inject('configProvider', ConfigConsumerProps),
      rowContext: inject('rowContext', null)
    };
  },
  methods: {
    parseFlex: function parseFlex(flex) {
      if (typeof flex === 'number') {
        return "".concat(flex, " ").concat(flex, " auto");
      }

      if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
        return "0 0 ".concat(flex);
      }

      return flex;
    }
  },
  render: function render() {
    var _this = this,
        _objectSpread3;

    var span = this.span,
        order = this.order,
        offset = this.offset,
        push = this.push,
        pull = this.pull,
        flex = this.flex,
        customizePrefixCls = this.prefixCls,
        rowContext = this.rowContext;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('col', customizePrefixCls);
    var sizeClassObj = {};
    ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'].forEach(function (size) {
      var _objectSpread2;

      var sizeProps = {};
      var propSize = _this[size];

      if (typeof propSize === 'number') {
        sizeProps.span = propSize;
      } else if (_typeof(propSize) === 'object') {
        sizeProps = propSize || {};
      }

      sizeClassObj = _objectSpread(_objectSpread({}, sizeClassObj), {}, (_objectSpread2 = {}, _defineProperty(_objectSpread2, "".concat(prefixCls, "-").concat(size, "-").concat(sizeProps.span), sizeProps.span !== undefined), _defineProperty(_objectSpread2, "".concat(prefixCls, "-").concat(size, "-order-").concat(sizeProps.order), sizeProps.order || sizeProps.order === 0), _defineProperty(_objectSpread2, "".concat(prefixCls, "-").concat(size, "-offset-").concat(sizeProps.offset), sizeProps.offset || sizeProps.offset === 0), _defineProperty(_objectSpread2, "".concat(prefixCls, "-").concat(size, "-push-").concat(sizeProps.push), sizeProps.push || sizeProps.push === 0), _defineProperty(_objectSpread2, "".concat(prefixCls, "-").concat(size, "-pull-").concat(sizeProps.pull), sizeProps.pull || sizeProps.pull === 0), _objectSpread2));
    });

    var classes = _objectSpread((_objectSpread3 = {}, _defineProperty(_objectSpread3, "".concat(prefixCls), true), _defineProperty(_objectSpread3, "".concat(prefixCls, "-").concat(span), span !== undefined), _defineProperty(_objectSpread3, "".concat(prefixCls, "-order-").concat(order), order), _defineProperty(_objectSpread3, "".concat(prefixCls, "-offset-").concat(offset), offset), _defineProperty(_objectSpread3, "".concat(prefixCls, "-push-").concat(push), push), _defineProperty(_objectSpread3, "".concat(prefixCls, "-pull-").concat(pull), pull), _objectSpread3), sizeClassObj);

    var divProps = {
      class: classes,
      style: {}
    };

    if (rowContext) {
      var gutter = rowContext.getGutter();

      if (gutter) {
        divProps.style = _objectSpread(_objectSpread({}, gutter[0] > 0 ? {
          paddingLeft: "".concat(gutter[0] / 2, "px"),
          paddingRight: "".concat(gutter[0] / 2, "px")
        } : {}), gutter[1] > 0 ? {
          paddingTop: "".concat(gutter[1] / 2, "px"),
          paddingBottom: "".concat(gutter[1] / 2, "px")
        } : {});
      }
    }

    if (flex) {
      divProps.style.flex = this.parseFlex(flex);
    }

    return createVNode("div", divProps, [getSlot(this)]);
  }
};