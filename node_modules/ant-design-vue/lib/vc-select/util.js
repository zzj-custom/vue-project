"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toTitle = toTitle;
exports.getValuePropValue = getValuePropValue;
exports.getPropValue = getPropValue;
exports.isMultiple = isMultiple;
exports.isCombobox = isCombobox;
exports.isMultipleOrTags = isMultipleOrTags;
exports.isMultipleOrTagsOrCombobox = isMultipleOrTagsOrCombobox;
exports.isSingleMode = isSingleMode;
exports.toArray = toArray;
exports.getMapKey = getMapKey;
exports.preventDefaultEvent = preventDefaultEvent;
exports.findIndexInValueBySingleValue = findIndexInValueBySingleValue;
exports.getLabelFromPropsValue = getLabelFromPropsValue;
exports.getSelectKeys = getSelectKeys;
exports.findFirstMenuItem = findFirstMenuItem;
exports.includesSeparators = includesSeparators;
exports.splitBySeparators = splitBySeparators;
exports.defaultFilterFn = defaultFilterFn;
exports.validateOptionValue = validateOptionValue;
exports.saveRef = saveRef;
exports.generateUUID = generateUUID;
exports.UNSELECTABLE_ATTRIBUTE = exports.UNSELECTABLE_STYLE = void 0;

var _propsUtil = require("../_util/props-util");

var _vnode = require("../_util/vnode");

var _vue = require("vue");

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function toTitle(title) {
  if (typeof title === 'string') {
    return title.trim();
  }

  return '';
}

function getValuePropValue(child) {
  if (!child) {
    return null;
  }

  var props = (0, _propsUtil.getPropsData)(child);

  if ('value' in props) {
    return props.value;
  }

  if (child.key !== undefined) {
    return child.key;
  }

  if (_typeof(child.type) === 'object' && child.type.isSelectOptGroup) {
    var label = (0, _propsUtil.getComponent)(child, 'label');

    if (label) {
      return label;
    }
  }

  throw new Error("Need at least a key or a value or a label (only for OptGroup) for ".concat(child));
}

function getPropValue(child, prop) {
  if (prop === 'value') {
    return getValuePropValue(child);
  }

  if (prop === 'children') {
    var temp = (0, _propsUtil.getComponent)(child);
    var newChild = (0, _vue.isVNode)(temp) ? (0, _vnode.cloneElement)(temp) : temp;

    if ((0, _vue.isVNode)(newChild) && newChild.type === _vue.Text) {
      return newChild.children;
    }

    return newChild;
  }

  var props = (0, _propsUtil.getPropsData)(child);
  return props[prop];
}

function isMultiple(props) {
  return props.multiple;
}

function isCombobox(props) {
  return props.combobox;
}

function isMultipleOrTags(props) {
  return props.multiple || props.tags;
}

function isMultipleOrTagsOrCombobox(props) {
  return isMultipleOrTags(props) || isCombobox(props);
}

function isSingleMode(props) {
  return !isMultipleOrTagsOrCombobox(props);
}

function toArray(value) {
  var ret = value;

  if (value === undefined) {
    ret = [];
  } else if (!Array.isArray(value)) {
    ret = [value];
  }

  return ret;
}

function getMapKey(value) {
  return "".concat(_typeof(value), "-").concat(value);
}

function preventDefaultEvent(e) {
  e.preventDefault();
}

function findIndexInValueBySingleValue(value, singleValue) {
  var index = -1;

  if (value) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === singleValue) {
        index = i;
        break;
      }
    }
  }

  return index;
}

function getLabelFromPropsValue(value, key) {
  var label;
  value = toArray(value);

  if (value) {
    for (var i = 0; i < value.length; i++) {
      if (value[i].key === key) {
        label = value[i].label;
        break;
      }
    }
  }

  return label;
}

function getSelectKeys() {
  var menuItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var value = arguments.length > 1 ? arguments[1] : undefined;

  if (value === null || value === undefined) {
    return [];
  }

  var selectedKeys = [];
  menuItems.forEach(function (item) {
    var _item$type;

    if ((_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.isMenuItemGroup) {
      selectedKeys = selectedKeys.concat(getSelectKeys((0, _propsUtil.getSlot)(item), value));
    } else {
      var itemValue = getValuePropValue(item);
      var itemKey = item.key;

      if (findIndexInValueBySingleValue(value, itemValue) !== -1 && itemKey !== undefined) {
        selectedKeys.push(itemKey);
      }
    }
  });
  return selectedKeys;
}

var UNSELECTABLE_STYLE = {
  userSelect: 'none',
  WebkitUserSelect: 'none'
};
exports.UNSELECTABLE_STYLE = UNSELECTABLE_STYLE;
var UNSELECTABLE_ATTRIBUTE = {
  unselectable: 'on'
};
exports.UNSELECTABLE_ATTRIBUTE = UNSELECTABLE_ATTRIBUTE;

function findFirstMenuItem(children) {
  for (var i = 0; i < children.length; i++) {
    var _child$type;

    var child = children[i];
    var props = (0, _propsUtil.getPropsData)(child);

    if ((_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.isMenuItemGroup) {
      var found = findFirstMenuItem((0, _propsUtil.getSlot)(child));

      if (found) {
        return found;
      }
    } else if (!props.disabled) {
      return child;
    }
  }

  return null;
}

function includesSeparators(str, separators) {
  for (var i = 0; i < separators.length; ++i) {
    if (str.lastIndexOf(separators[i]) > 0) {
      return true;
    }
  }

  return false;
}

function splitBySeparators(str, separators) {
  var reg = new RegExp("[".concat(separators.join(), "]"));
  return str.split(reg).filter(function (token) {
    return token;
  });
}

function defaultFilterFn(input, child) {
  var props = (0, _propsUtil.getPropsData)(child);

  if (props.disabled) {
    return false;
  }

  var value = getPropValue(child, this.optionFilterProp);

  if (value.length && value[0].text) {
    value = value[0].text;
  } else {
    value = String(value);
  }

  return value.toLowerCase().indexOf(input.toLowerCase()) > -1;
}

function validateOptionValue(value, props) {
  if (isSingleMode(props) || isMultiple(props)) {
    return;
  }

  if (typeof value !== 'string') {
    throw new Error("Invalid `value` of type `".concat(_typeof(value), "` supplied to Option, ") + "expected `string` when `tags/combobox` is `true`.");
  }
}

function saveRef(instance, name) {
  return function (node) {
    instance[name] = node;
  };
}

function generateUUID() {
  if (process.env.NODE_ENV === 'test') {
    return 'test-uuid';
  }

  var d = new Date().getTime();
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === 'x' ? r : r & 0x7 | 0x8).toString(16);
  });
  return uuid;
}