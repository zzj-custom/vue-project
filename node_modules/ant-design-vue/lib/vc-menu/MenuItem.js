"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.menuItemProps = exports.default = void 0;

var _vue = require("vue");

var _vueTypes = _interopRequireDefault(require("../_util/vue-types"));

var _KeyCode = _interopRequireDefault(require("../_util/KeyCode"));

var _BaseMixin = _interopRequireDefault(require("../_util/BaseMixin"));

var _domScrollIntoView = _interopRequireDefault(require("dom-scroll-into-view"));

var _store = require("../_util/store");

var _util = require("./util");

var _propsUtil = require("../_util/props-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var props = {
  attribute: _vueTypes.default.object,
  rootPrefixCls: _vueTypes.default.string,
  eventKey: _vueTypes.default.oneOfType([_vueTypes.default.string, _vueTypes.default.number]),
  active: _vueTypes.default.bool,
  selectedKeys: _vueTypes.default.array,
  disabled: _vueTypes.default.bool,
  title: _vueTypes.default.any,
  index: _vueTypes.default.number,
  inlineIndent: _vueTypes.default.number.def(24),
  level: _vueTypes.default.number.def(1),
  mode: _vueTypes.default.oneOf(['horizontal', 'vertical', 'vertical-left', 'vertical-right', 'inline']),
  multiple: _vueTypes.default.bool,
  value: _vueTypes.default.any,
  isSelected: _vueTypes.default.bool,
  manualRef: _vueTypes.default.func.def(_util.noop),
  role: _vueTypes.default.any,
  subMenuKey: _vueTypes.default.string,
  itemIcon: _vueTypes.default.any // clearSubMenuTimers: PropTypes.func.def(noop),

};
exports.menuItemProps = props;
var MenuItem = {
  name: 'AMenuItem',
  inheritAttrs: false,
  props: props,
  mixins: [_BaseMixin.default],
  isMenuItem: true,
  setup: function setup() {
    return {
      parentMenu: (0, _vue.inject)('parentMenu', undefined)
    };
  },
  created: function created() {
    this.prevActive = this.active; // invoke customized ref to expose component to mixin

    this.callRef();
  },
  updated: function updated() {
    var _this = this;

    this.$nextTick(function () {
      var active = _this.active,
          parentMenu = _this.parentMenu,
          eventKey = _this.eventKey;

      if (!_this.prevActive && active && (!parentMenu || !parentMenu["scrolled-".concat(eventKey)])) {
        (0, _domScrollIntoView.default)((0, _propsUtil.findDOMNode)(_this.node), (0, _propsUtil.findDOMNode)(parentMenu), {
          onlyScrollIfNeeded: true
        });
        parentMenu["scrolled-".concat(eventKey)] = true;
      } else if (parentMenu && parentMenu["scrolled-".concat(eventKey)]) {
        delete parentMenu["scrolled-".concat(eventKey)];
      }

      _this.prevActive = active;
    });
    this.callRef();
  },
  beforeUnmount: function beforeUnmount() {
    var props = this.$props;

    this.__emit('destroy', props.eventKey);
  },
  methods: {
    onKeyDown: function onKeyDown(e) {
      var keyCode = e.keyCode;

      if (keyCode === _KeyCode.default.ENTER) {
        this.onClick(e);
        return true;
      }
    },
    onMouseLeave: function onMouseLeave(e) {
      var eventKey = this.$props.eventKey;

      this.__emit('itemHover', {
        key: eventKey,
        hover: false
      });

      this.__emit('mouseleave', {
        key: eventKey,
        domEvent: e
      });
    },
    onMouseEnter: function onMouseEnter(e) {
      var eventKey = this.eventKey;

      this.__emit('itemHover', {
        key: eventKey,
        hover: true
      });

      this.__emit('mouseenter', {
        key: eventKey,
        domEvent: e
      });
    },
    onClick: function onClick(e) {
      var _this$$props = this.$props,
          eventKey = _this$$props.eventKey,
          multiple = _this$$props.multiple,
          isSelected = _this$$props.isSelected;
      var info = {
        key: eventKey,
        keyPath: [eventKey],
        item: this,
        domEvent: e
      };

      this.__emit('click', info);

      if (multiple) {
        if (isSelected) {
          this.__emit('deselect', info);
        } else {
          this.__emit('select', info);
        }
      } else if (!isSelected) {
        this.__emit('select', info);
      }
    },
    getPrefixCls: function getPrefixCls() {
      return "".concat(this.$props.rootPrefixCls, "-item");
    },
    getActiveClassName: function getActiveClassName() {
      return "".concat(this.getPrefixCls(), "-active");
    },
    getSelectedClassName: function getSelectedClassName() {
      return "".concat(this.getPrefixCls(), "-selected");
    },
    getDisabledClassName: function getDisabledClassName() {
      return "".concat(this.getPrefixCls(), "-disabled");
    },
    saveNode: function saveNode(node) {
      this.node = node;
    },
    callRef: function callRef() {
      if (this.manualRef) {
        this.manualRef(this);
      }
    }
  },
  render: function render() {
    var _className;

    var _this$$props$this$$at = _objectSpread(_objectSpread({}, this.$props), this.$attrs),
        cls = _this$$props$this$$at.class,
        style = _this$$props$this$$at.style,
        props = _objectWithoutProperties(_this$$props$this$$at, ["class", "style"]);

    var className = (_className = {}, _defineProperty(_className, cls, !!cls), _defineProperty(_className, this.getPrefixCls(), true), _defineProperty(_className, this.getActiveClassName(), !props.disabled && props.active), _defineProperty(_className, this.getSelectedClassName(), props.isSelected), _defineProperty(_className, this.getDisabledClassName(), props.disabled), _className);

    var attrs = _objectSpread(_objectSpread({}, props.attribute), {}, {
      title: props.title,
      role: props.role || 'menuitem',
      'aria-disabled': props.disabled
    });

    if (props.role === 'option') {
      // overwrite to option
      attrs = _objectSpread(_objectSpread({}, attrs), {}, {
        role: 'option',
        'aria-selected': props.isSelected
      });
    } else if (props.role === null || props.role === 'none') {
      // sometimes we want to specify role inside <li/> element
      // <li><a role='menuitem'>Link</a></li> would be a good example
      // in this case the role on <li/> should be "none" to
      // remove the implied listitem role.
      // https://www.w3.org/TR/wai-aria-practices-1.1/examples/menubar/menubar-1/menubar-1.html
      attrs.role = 'none';
    } // In case that onClick/onMouseLeave/onMouseEnter is passed down from owner


    var mouseEvent = {
      onClick: props.disabled ? _util.noop : this.onClick,
      onMouseleave: props.disabled ? _util.noop : this.onMouseLeave,
      onMouseenter: props.disabled ? _util.noop : this.onMouseEnter
    };

    var styles = _objectSpread({}, style || {});

    if (props.mode === 'inline') {
      styles.paddingLeft = "".concat(props.inlineIndent * props.level, "px");
    }

    _util.menuAllProps.forEach(function (key) {
      return delete props[key];
    });

    var liProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, props), attrs), mouseEvent), {}, {
      ref: this.saveNode
    });

    delete liProps.children;
    return (0, _vue.createVNode)("li", (0, _vue.mergeProps)(liProps, {
      "style": styles,
      "class": className
    }), [(0, _propsUtil.getSlot)(this), (0, _propsUtil.getComponent)(this, 'itemIcon', props)]);
  }
};
var connected = (0, _store.connect)(function (_ref, _ref2) {
  var activeKey = _ref.activeKey,
      selectedKeys = _ref.selectedKeys;
  var eventKey = _ref2.eventKey,
      subMenuKey = _ref2.subMenuKey;
  return {
    active: activeKey[subMenuKey] === eventKey,
    isSelected: selectedKeys.indexOf(eventKey) !== -1
  };
})(MenuItem);
var _default = connected;
exports.default = _default;