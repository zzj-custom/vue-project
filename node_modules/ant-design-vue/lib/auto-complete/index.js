"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _vue = require("vue");

var _vcSelect = require("../vc-select");

var _select = _interopRequireWildcard(require("../select"));

var _input = _interopRequireDefault(require("../input"));

var _InputElement = _interopRequireDefault(require("./InputElement"));

var _vueTypes = _interopRequireDefault(require("../_util/vue-types"));

var _configProvider = require("../config-provider");

var _propsUtil = require("../_util/props-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// const DataSourceItemObject = PropTypes.shape({
//   value: String,
//   text: String,
// }).loose
// const DataSourceItemType = PropTypes.oneOfType([
//   PropTypes.string,
//   DataSourceItemObject,
// ]).isRequired
// export interface AutoCompleteInputProps {
//   onChange?: React.FormEventHandler<any>;
//   value: any;
// }
function isSelectOptionOrSelectOptGroup(child) {
  return child && child.type && (child.type.isSelectOption || child.type.isSelectOptGroup);
}

var AutoCompleteProps = _objectSpread(_objectSpread({}, (0, _select.AbstractSelectProps)()), {}, {
  value: _select.SelectValue,
  defaultValue: _select.SelectValue,
  dataSource: _vueTypes.default.array,
  dropdownMenuStyle: _vueTypes.default.object,
  optionLabelProp: String,
  dropdownMatchSelectWidth: _vueTypes.default.bool // onChange?: (value: SelectValue) => void;
  // onSelect?: (value: SelectValue, option: Object) => any;

});

var AutoComplete = {
  name: 'AAutoComplete',
  inheritAttrs: false,
  props: _objectSpread(_objectSpread({}, AutoCompleteProps), {}, {
    prefixCls: _vueTypes.default.string.def('ant-select'),
    showSearch: _vueTypes.default.bool.def(false),
    transitionName: _vueTypes.default.string.def('slide-up'),
    choiceTransitionName: _vueTypes.default.string.def('zoom'),
    autofocus: _vueTypes.default.bool,
    backfill: _vueTypes.default.bool,
    optionLabelProp: _vueTypes.default.string.def('children'),
    filterOption: _vueTypes.default.oneOfType([_vueTypes.default.bool, _vueTypes.default.func]).def(false),
    defaultActiveFirstOption: _vueTypes.default.bool.def(true)
  }),
  Option: _objectSpread(_objectSpread({}, _vcSelect.Option), {}, {
    name: 'AAutoCompleteOption'
  }),
  OptGroup: _objectSpread(_objectSpread({}, _vcSelect.OptGroup), {}, {
    name: 'AAutoCompleteOptGroup'
  }),
  // model: {
  //   prop: 'value',
  //   event: 'change',
  // },
  setup: function setup() {
    return {
      configProvider: (0, _vue.inject)('configProvider', _configProvider.ConfigConsumerProps)
    };
  },
  created: function created() {
    (0, _vue.provide)('savePopupRef', this.savePopupRef);
  },
  methods: {
    savePopupRef: function savePopupRef(ref) {
      this.popupRef = ref;
    },
    saveSelect: function saveSelect(node) {
      this.select = node;
    },
    getInputElement: function getInputElement() {
      var children = (0, _propsUtil.getSlot)(this);
      var element = children.length ? children[0] : (0, _vue.createVNode)(_input.default, {
        "lazy": false
      }, null);
      return (0, _vue.createVNode)(_InputElement.default, (0, _vue.mergeProps)({
        "placeholder": this.placeholder
      }, element.props), {
        default: function _default() {
          return [element];
        }
      });
    },
    focus: function focus() {
      if (this.select) {
        this.select.focus();
      }
    },
    blur: function blur() {
      if (this.select) {
        this.select.blur();
      }
    }
  },
  render: function render() {
    var _cls;

    var size = this.size,
        customizePrefixCls = this.prefixCls,
        optionLabelProp = this.optionLabelProp,
        dataSource = this.dataSource;
    var getPrefixCls = this.configProvider.getPrefixCls;
    var prefixCls = getPrefixCls('select', customizePrefixCls);
    var className = this.$attrs.class;
    var cls = (_cls = {}, _defineProperty(_cls, className, !!className), _defineProperty(_cls, "".concat(prefixCls, "-lg"), size === 'large'), _defineProperty(_cls, "".concat(prefixCls, "-sm"), size === 'small'), _defineProperty(_cls, "".concat(prefixCls, "-show-search"), true), _defineProperty(_cls, "".concat(prefixCls, "-auto-complete"), true), _cls);
    var options;
    var childArray = (0, _propsUtil.getSlot)(this, 'dataSource');

    if (childArray.length && isSelectOptionOrSelectOptGroup(childArray[0])) {
      options = childArray;
    } else {
      options = dataSource ? dataSource.map(function (item) {
        if ((0, _propsUtil.isValidElement)(item)) {
          return item;
        }

        switch (_typeof(item)) {
          case 'string':
            return (0, _vue.createVNode)(_vcSelect.Option, {
              "key": item
            }, {
              default: function _default() {
                return [item];
              }
            });

          case 'object':
            return (0, _vue.createVNode)(_vcSelect.Option, {
              "key": item.value
            }, {
              default: function _default() {
                return [item.text];
              }
            });

          default:
            throw new Error('AutoComplete[dataSource] only supports type `string[] | Object[]`.');
        }
      }) : [];
    }

    var selectProps = _objectSpread(_objectSpread(_objectSpread({}, (0, _propsUtil.getOptionProps)(this)), this.$attrs), {}, {
      mode: _select.default.SECRET_COMBOBOX_MODE_DO_NOT_USE,
      optionLabelProp: optionLabelProp,
      getInputElement: this.getInputElement,
      notFoundContent: (0, _propsUtil.getComponent)(this, 'notFoundContent'),
      placeholder: '',
      class: cls,
      ref: this.saveSelect
    });

    return (0, _vue.createVNode)(_select.default, selectProps, {
      default: function _default() {
        return [options];
      }
    });
  }
};
/* istanbul ignore next */

AutoComplete.install = function (app) {
  app.component(AutoComplete.name, AutoComplete);
  app.component(AutoComplete.Option.name, AutoComplete.Option);
  app.component(AutoComplete.OptGroup.name, AutoComplete.OptGroup);
};

var _default2 = AutoComplete;
exports.default = _default2;