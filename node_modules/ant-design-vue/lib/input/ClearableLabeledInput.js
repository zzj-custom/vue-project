"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasPrefixSuffix = hasPrefixSuffix;
exports.default = void 0;

var _vue = require("vue");

var _classNames4 = _interopRequireDefault(require("../_util/classNames"));

var _CloseCircleFilled = _interopRequireDefault(require("@ant-design/icons-vue/CloseCircleFilled"));

var _Input = require("./Input");

var _vueTypes = _interopRequireDefault(require("../_util/vue-types"));

var _vnode = require("../_util/vnode");

var _propsUtil = require("../_util/props-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function hasPrefixSuffix(instance) {
  return !!((0, _propsUtil.getComponent)(instance, 'prefix') || (0, _propsUtil.getComponent)(instance, 'suffix') || instance.$props.allowClear);
}

var ClearableInputType = ['text', 'input'];
var ClearableLabeledInput = {
  name: 'ClearableLabeledInput',
  inheritAttrs: false,
  props: {
    prefixCls: _vueTypes.default.string,
    inputType: _vueTypes.default.oneOf(ClearableInputType),
    value: _vueTypes.default.any,
    defaultValue: _vueTypes.default.any,
    allowClear: _vueTypes.default.bool,
    element: _vueTypes.default.any,
    handleReset: _vueTypes.default.func,
    disabled: _vueTypes.default.bool,
    size: _vueTypes.default.oneOf(['small', 'large', 'default']),
    suffix: _vueTypes.default.any,
    prefix: _vueTypes.default.any,
    addonBefore: _vueTypes.default.any,
    addonAfter: _vueTypes.default.any,
    readonly: _vueTypes.default.bool
  },
  methods: {
    renderClearIcon: function renderClearIcon(prefixCls) {
      var _this$$props = this.$props,
          allowClear = _this$$props.allowClear,
          value = _this$$props.value,
          disabled = _this$$props.disabled,
          readonly = _this$$props.readonly,
          inputType = _this$$props.inputType,
          handleReset = _this$$props.handleReset;

      if (!allowClear || disabled || readonly || value === undefined || value === null || value === '') {
        return null;
      }

      var className = inputType === ClearableInputType[0] ? "".concat(prefixCls, "-textarea-clear-icon") : "".concat(prefixCls, "-clear-icon");
      return (0, _vue.createVNode)(_CloseCircleFilled.default, {
        "onClick": handleReset,
        "class": className,
        "role": "button"
      }, null);
    },
    renderSuffix: function renderSuffix(prefixCls) {
      var _this$$props2 = this.$props,
          suffix = _this$$props2.suffix,
          allowClear = _this$$props2.allowClear;

      if (suffix || allowClear) {
        return (0, _vue.createVNode)("span", {
          "class": "".concat(prefixCls, "-suffix")
        }, [this.renderClearIcon(prefixCls), suffix]);
      }

      return null;
    },
    renderLabeledIcon: function renderLabeledIcon(prefixCls, element) {
      var _this$$attrs, _classNames;

      var props = this.$props;
      var suffix = this.renderSuffix(prefixCls);

      if (!hasPrefixSuffix(this)) {
        return (0, _vnode.cloneElement)(element, {
          value: props.value
        });
      }

      var prefix = props.prefix ? (0, _vue.createVNode)("span", {
        "class": "".concat(prefixCls, "-prefix")
      }, [props.prefix]) : null;
      var affixWrapperCls = (0, _classNames4.default)((_this$$attrs = this.$attrs) === null || _this$$attrs === void 0 ? void 0 : _this$$attrs.class, "".concat(prefixCls, "-affix-wrapper"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-affix-wrapper-sm"), props.size === 'small'), _defineProperty(_classNames, "".concat(prefixCls, "-affix-wrapper-lg"), props.size === 'large'), _defineProperty(_classNames, "".concat(prefixCls, "-affix-wrapper-input-with-clear-btn"), props.suffix && props.allowClear && this.$props.value), _classNames));
      return (0, _vue.createVNode)("span", {
        "class": affixWrapperCls,
        "style": props.style
      }, [prefix, (0, _vnode.cloneElement)(element, {
        style: null,
        value: props.value,
        class: (0, _Input.getInputClassName)(prefixCls, props.size, props.disabled)
      }), suffix]);
    },
    renderInputWithLabel: function renderInputWithLabel(prefixCls, labeledElement) {
      var _classNames3;

      var _this$$props3 = this.$props,
          addonBefore = _this$$props3.addonBefore,
          addonAfter = _this$$props3.addonAfter,
          size = _this$$props3.size;
      var _this$$attrs2 = this.$attrs,
          style = _this$$attrs2.style,
          className = _this$$attrs2.class; // Not wrap when there is not addons

      if (!addonBefore && !addonAfter) {
        return labeledElement;
      }

      var wrapperClassName = "".concat(prefixCls, "-group");
      var addonClassName = "".concat(wrapperClassName, "-addon");
      var addonBeforeNode = addonBefore ? (0, _vue.createVNode)("span", {
        "class": addonClassName
      }, [addonBefore]) : null;
      var addonAfterNode = addonAfter ? (0, _vue.createVNode)("span", {
        "class": addonClassName
      }, [addonAfter]) : null;
      var mergedWrapperClassName = (0, _classNames4.default)("".concat(prefixCls, "-wrapper"), _defineProperty({}, wrapperClassName, addonBefore || addonAfter));
      var mergedGroupClassName = (0, _classNames4.default)(className, "".concat(prefixCls, "-group-wrapper"), (_classNames3 = {}, _defineProperty(_classNames3, "".concat(prefixCls, "-group-wrapper-sm"), size === 'small'), _defineProperty(_classNames3, "".concat(prefixCls, "-group-wrapper-lg"), size === 'large'), _classNames3)); // Need another wrapper for changing display:table to display:inline-block
      // and put style prop in wrapper

      return (0, _vue.createVNode)("span", {
        "class": mergedGroupClassName,
        "style": style
      }, [(0, _vue.createVNode)("span", {
        "class": mergedWrapperClassName
      }, [addonBeforeNode, (0, _vnode.cloneElement)(labeledElement, {
        style: null
      }), addonAfterNode])]);
    },
    renderTextAreaWithClearIcon: function renderTextAreaWithClearIcon(prefixCls, element) {
      var _this$$props4 = this.$props,
          value = _this$$props4.value,
          allowClear = _this$$props4.allowClear;
      var _this$$attrs3 = this.$attrs,
          style = _this$$attrs3.style,
          className = _this$$attrs3.class;

      if (!allowClear) {
        return (0, _vnode.cloneElement)(element, {
          value: value
        });
      }

      var affixWrapperCls = (0, _classNames4.default)(className, "".concat(prefixCls, "-affix-wrapper"), "".concat(prefixCls, "-affix-wrapper-textarea-with-clear-btn"));
      return (0, _vue.createVNode)("span", {
        "class": affixWrapperCls,
        "style": style
      }, [(0, _vnode.cloneElement)(element, {
        style: null,
        value: value
      }), this.renderClearIcon(prefixCls)]);
    },
    renderClearableLabeledInput: function renderClearableLabeledInput() {
      var _this$$props5 = this.$props,
          prefixCls = _this$$props5.prefixCls,
          inputType = _this$$props5.inputType,
          element = _this$$props5.element;

      if (inputType === ClearableInputType[0]) {
        return this.renderTextAreaWithClearIcon(prefixCls, element);
      }

      return this.renderInputWithLabel(prefixCls, this.renderLabeledIcon(prefixCls, element));
    }
  },
  render: function render() {
    return this.renderClearableLabeledInput();
  }
};
var _default = ClearableLabeledInput;
exports.default = _default;